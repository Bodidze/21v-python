# 21v-python

# Python поддерживает парадигму функционального программирования

## Определение и использование функции

1 Функция в Python может быть определена с помощью оператора def или лямбда-выражением. Следующие операторы эквивалентны:
```
def func(x, y):
    return x**2 + y**2

func = lambda x, y: x**2 + y**2
```
В определении функции фигурируют формальные аргументы. Некоторые из них могут иметь значения по умолчанию. Все аргументы со значениями по умолчанию следуют после аргументов без значений по умолчанию.

При вызове функции задаются фактические аргументы. Например:
```
func(2, y=7)
```
В начале идут позиционные аргументы. Они сопоставляются с именами формальных аргументов по порядку. Затем следуют именованные аргументы. Они сопоставляются по именам и могут быть заданы в вызове функции в любом порядке. Разумеется, все аргументы, для которых в описании функции не указаны значения по умолчанию, должны присутствовать в вызове функции. Повторы в именах аргументов недопустимы.

Функция всегда возвращает только одно значение (или None, если значение не задано в операторе return или этот оператор не встречен по достижении конца определения функции). Однако, это незначительное ограничение, так как возвращаемым значением может быть кортеж.

Функции в Python являются объектами первого класса, то есть, они могут употребляться в программе наравне с объектами других типов данных.

# Рекурсия

# пример вычисления факториала
```
def factorial(n):
     if n <= 1: return 1
     else: return n*factorial (n-1)
```
Существует ограничение на глубину рекурсии. По умолчанию предел равен 1000.


# Списковые включения

Списковое включение (list comprehension) — наиболее выразительное из функциональных средств Python. 

для вычисления списка квадратов положительных целых чисел, меньших 10, можно использовать выражение:
```
l = [x**2 for x in range(10)]

```
Цикл с условием
```
for x in xrange(5, 10):
    if x % 2 == 0:
        x =* 2
    else:
        x += 1

[x * 2 if x % 2 == 0 else x + 1 for x in xrange(5, 10)]
[6, 12, 8, 16, 10]
```
В общем виде эта конструкция такова:
```
[stmt for var in iterable if predicate] 

```
# Анонимные функции или lambda

Функция:
```
def calc(x, y):
    return x**2 + y**2
```
1. Анонимные функции в Python реализуются с помощью лямбда-исчисления и выглядят как лямбда-выражения:
```
lambda x, y: x**2 + y**2

```
Определив функцию с помощью лямбда-выражения, можно тут же ее использовать:
```
(lambda x: x+2)(5)
```
Чтобы обращаться к анонимным функциям несколько раз:
```
(lambda x, y: x**2 + y**2)(1, 4)
17

func = lambda x, y: x**2 + y**2
func(1, 4)
17

#вывести True, если число четное и False в противном случае

g = lambda x: not bool(x % 2)
print g(4)

```
Лямбда-выражения удобны для определения не очень сложных функций, которые передаются затем другим функциям.

2. Лямбда-функции могут выступать в качестве аргумента. Даже для других лямбд:
```
summer = lambda a: lambda b: a+b
multiplier = lambda n: lambda k: n*k

print summer(100)(100)
print multiplier(100)(100)

```
# ?-исчисления
Lambda исчисления – это математическая концепция, которая подразумевает, что функции могут принимать в качестве аргументов и возвращать другие функции.

Такие функции называются функциями высших порядков. ?-исчисления основываются на двух операциях: аппликация и абстракция.
Функции map, reduce – это и есть те самые функции высших порядков, которые «апплицируют», или применяют, переданную в качестве аргумента функцию к каждому элементу списка (для map) или каждой последовательной паре элементов списка (для reduce).

3. Что касается абстракции – здесь наоборот, функции создают новые функции на основе своих аргументов.

# Lambda-абстракция
```
def add(n): 
return lambda x: x + n

adds = [add(x) for x in xrange(100)]

adds[34](5)
```
Здесь мы создали список функций, каждая из которых прибавляет к аргументу определенное число.

Сохранение в структурах данных.
```
def function1():
    print '1'
    
def function2():
    print '2'
    
def function3():
    print '3'

if value == 'one':
    function1()
elif value == 'two':
    function2()
elif value == 'three':
    function3()
```
можно переписать так:
```

switch = {
     'one': function1,
     'two': function2,
     'three': function3,
}

choice = raw_input('Enter one, two or three')
try:
     result = switch[choice]()  #получаем функцию и тут же вызываем ее
except KeyError:
     print "I didn\'t understand your choice"

```

# Args и Kwargs

* - синтаксис для распаковки кортежа, ** - для распаковки словаря.
Рассмотрим следующий пример.
```
def tuple_test(x,y):
     x += 1
     y += 1
     print x, y
```
Если мы попробуем подать на вход этой функции кортеж, то будет ошибка:
```
t = (1,2)
tuple_test(t) #ошибка!
```
Ошибка возникнет потому, что функции нужны 2 аргумента, а кортеж будет интерпретироваться как 1 аргумент. Для того, чтобы ошибки не было, кортеж нужно распаковать:
```
tuple_test(*t)
```

То же самое для словаря:
```
d = {'x':1, 'y': 2}
tuple_test(d) #ошибка!

tuple_test(**d)
```

Ключевые слова args и kwargs используются при задании функций в случаях, когда заранее не известно количество и состав аргументов функции. Например:
```
def foo(*args, **kwargs):
     return args if args else kwargs

print foo(1,2)
>>(1,2)

print foo(1,2,3)
>>(1,2,3)

print foo(x=1, y=2)
>>{'x': 1, 'y': 2}
```

# Функции высшего порядка
Функцию, принимающую другую функцию в качестве аргумента и/или возвращающую другую функцию, называют функцией высшего порядка:
```
def f(x):
    return x + 3

def g(function, x):
    return function(x) * function(x)

print(g(f, 7))

```
Функции в Python могут передаваться другим функциям в виде аргументов, сохраняться в структурах данных и возвращаться функциями в виде результата.

```
def callf(func):
     return func()

def helloworld():
     print "Привет, мир!"

callf(helloworld)
```
# Встроенные функции высших порядков

В Python есть функции, одним из аргументом которых являются другие функции: map(), filter(), reduce(), apply().

# map()

Функция map() позволяет обрабатывать одну или несколько последовательностей с помощью заданной функции 5:
```
list1 = [7, 2, 3, 10, 12]
list2 = [-1, 1, -5, 4, 6]
map(lambda x, y: x*y, list1, list2)
[-7, 2, -15, 40, 72]
```
Аналогичного (только при одинаковой длине списков) результата можно добиться с помощью списочных выражений:
```
[x*y for x, y in zip(list1, list2)]
[-7, 2, -15, 40, 72]

#узнать длины слов в предложении

sentence = "It is raining cats and dogs"
words = sentence.split()
lengths = map(lambda word: len(word), words)


```
# filter()

Функция filter() позволяет фильтровать значения последовательности. В результирующем списке только те значения, для которых значение функции для элемента истинно 6:
```
numbers = [10, 4, 2, -1, 6]
filter(lambda x: x < 5, numbers)     # В результат попадают только те элементы x, для которых x < 5 истинно
[4, 2, -1]
```
То же самое с помощью списковых выражений:
```
numbers = [10, 4, 2, -1, 6]
[x for x in numbers if x < 5]
[4, 2, -1]
```
# reduce()

Для организации цепочечных вычислений в списке можно использовать функцию reduce(). Например, произведение элементов списка может быть вычислено так 7:
```
numbers = [2, 3, 4, 5, 6]
reduce(lambda res, x: res*x, numbers, 1)
720
```
Вычисления происходят в следующем порядке:
```
((((1*2)*3)*4)*5)*6
```
Цепочка вызовов связывается с помощью промежуточного результата (res). Если список пустой, просто используется третий параметр (в случае произведения нуля множителей это 1):
```
reduce(lambda res, x: res*x, [], 1)
1
```
Разумеется, промежуточный результат необязательно число. Это может быть любой другой тип данных, в том числе и список. Следующий пример показывает реверс списка:
```
reduce(lambda res, x: [x]+res, [1, 2, 3, 4], [])
[4, 3, 2, 1]
```
Для наиболее распространенных операций в Python есть встроенные функции:
```
numbers = [1, 2, 3, 4, 5]
sum(numbers)
15

list(reversed(numbers))
[5, 4, 3, 2, 1]
```
В Python 3 встроенной функции reduce() нет, но её можно найти в модуле functools.

# apply()

Функция для применения другой функции к позиционным и именованным аргументам, заданным списком и словарем соответственно (Python 2) 8:
```
def f(x, y, z, a=None, b=None):
    print x, y, z, a, b

apply(f, [1, 2, 3], {'a': 4, 'b': 5})
1 2 3 4 5
```
В Python 3 вместо функции apply() следует использовать специальный синтаксис:
```
def f(x, y, z, a=None, b=None):
    print(x, y, z, a, b)

f(*[1, 2, 3], **{'a': 4, 'b': 5})
1 2 3 4 5
```

# Управление контекстом выполнения

В Python 2.5 появились средства для управления контекстом выполнения блока кода — оператор with и модуль contextlib.

Оператор может применяться в тех случаях, когда до и после некоторых действий должны обязательно выполняться некоторые другие действия, независимо от возбуждённых в блоке исключений или операторов return: файлы должны быть закрыты, ресурсы освобождены, перенаправление стандартного ввода вывода закончено и т. п. Оператор улучшает читаемость кода, а значит, помогает предотвращать ошибки.

Оператор with

Синтаксически выглядит так:
```
with выражение:
     блок кода
```
Упрощает код, который раньше использовал try...finally... для гарантированного исполнения завершающего кода. Например:
```
with open('f.txt', 'r') as f:
     for line in f:
     print line
```
В данном примере не только нам не нужно писать f.close(), т.к. из-за использования with файл автоматически будет закрыт, но и если в процессе чтения или обработки данных из файла возникнет ошибка, то файл все равно будет закрыт.


задача написать игру крестики-нолики на питоне. Напомним, что крестики-нолики это логическая игра для двух игроков на поле 3х3 клетки.
Для начала зададим поле. Поле у нас будет одномерным списком (list) с числами от 1 до 9. Для создания воспользуемся функцией range()
```
# -*- coding: utf-8 -*-

board = range(1,10)

```

Теперь напишем функцию, которая будет выводить наше поле в привычном формате.
```
def draw_board(board):
    print "-------------"
    for i in range(3):
        print "|", board[0+i*3], "|", board[1+i*3], "|", board[2+i*3], "|"
        print "-------------"
```
Пишем функцию take_input
```
def take_input(player_token):
    valid = False
    while not valid:
        player_answer = raw_input("Куда поставим " + player_token+"? ")
        try:
            player_answer = int(player_answer)
        except:
            print "Некорректный ввод. Вы уверены, что ввели число?"
        if player_answer >= 1 and player_answer <= 9:
            if (str(board[player_answer-1]) not in "XO"):
                board[player_answer-1] = player_token
                valid = True
            else:
                print "Эта клеточка уже занята"
        else:
            print "Некорректный ввод. Введите число от 1 до 9 чтобы походить."
```
take_input принимает параметр player_token - крестик или нолик, в зависимости от того, чей сейчас ход. Нам важно ограничить выбор пользователя числами от 1 до 9. Для этого мы используем конструкции try/except и if/else, чтобы удостовериться, что выбранная клеточка не занята. 
функция take_input не возвращает никакого значения, а только изменяет имеющийся список board.
Осталось написать функцию проверки игрового поля. Назовем эту функцию check_win.
```
def check_win(board):
    win_coord = ((0,1,2),(3,4,5),(6,7,8),(0,3,6),(1,4,7),(2,5,8),(0,4,8),(2,4,6))
    for each in win_coord:
        if board[each[0]] == board[each[1]] == board[each[2]]:
            return board[each[0]]
    return False
```
Проверка результатов игры крестики-нолики достаточно распространенная задача по программированию. В данном случае мы просто создали кортеж (tuple) с выигрышными координатами и прошлись циклом for по нему. Если символы во всех трех заданных клетках равны - возвращаем выигрышный символ, иначе - возвращаем значение False. При этом важно помнить, что непустая строка (наш выигрышный символ) при приведении ее к логическому типу вернет True.

Осталось создать функцию main, в которой мы соберем вместе все описанные функции.
```
def main(board):
    counter = 0
    win = False
    while not win:
        draw_board(board)
        if counter % 2 == 0:
            take_input("X")
        else:
            take_input("O")
        counter += 1
        if counter > 4:
            tmp = check_win(board)
            if tmp:
                print tmp, "выиграл!"
                win = True
                break
        if counter == 9:
            print "Ничья!"
            break
    draw_board(board)

main(board)
```
Мы ждем когда переменная counter станет больше 4 для того, чтобы избежать заведомо ненужного вызова функции check_win (до пятого хода никто точно не может выиграть). Переменная tmp была создана опять же для того, чтобы лишний раз не вызывать функцию check_win, мы просто "запоминаем" ее значение и при необходимости используем на строке 48. Польза от такого подхода не так заметна при работе с небольшими объемами данных, но в целом подобная экономия процессорного времени - хорошая практика.
Теперь мы можем спокойно играть, запустив main(board)


# Модуль functools

## Итераторы

Другие средства функционального программирования доступны из стандартной библиотеки (например, модуль itertools) и других библиотек.

Следующий пример иллюстрирует применение перечисляющего и сортирующего итераторов (итератор не может быть напечатан оператором print, поэтому оставшиеся в нем значения были помещены в список):
```
it = enumerate(sorted("PYTHON"))  # итератор для перечисленных отсортированных букв слова
it.next()                         # следующее значение
(0, 'H')
print list(it)                    # оставшиеся значения в виде списка
[(1, 'N'), (2, 'O'), (3, 'P'), (4, 'T'), (5, 'Y')]
```
Следующий пример иллюстрирует использование модуля itertools:
```
from itertools import chain
print list(chain(iter("ABC"), iter("DEF")))
['A', 'B', 'C', 'D', 'E', 'F']
```
В следующем примере иллюстрируется функция groupby (группировать по), с помощью которой порождается список пар значение ключа и соответствующий ключу итератор (в этот итератор собраны все значения исходного списка с одинаковым значением ключа). В примере ключом является True или False в зависимости от положительности значения. (Для целей вывода каждый итератор превращается в список).
```
from math import cos
from itertools import groupby
lst = [cos(x*.4) for x in range(30)]                       # косинусоида
[list(y) for k, y in groupby(lst, lambda x: x > 0)]        # группы положительных и отрицательных чисел
```
В модуле itertools есть и другие функции для работы с итераторами, позволяющие кратко (в функциональном стиле) и с вычислительной точки зрения — эффективно — выразить требуемые процессы обработки списков.

Итераторы в Python являются неотъемлемой частью языка и во многих случаях неявно используются в выражении for (цикл просмотра), в работе со списками и в выражениях генератора. Все стандартные типы циклов, являющиеся частью языка Python, поддерживают итерацию, так же как и множество классов, являющихся частью стандартной библиотеки. Следующий пример демонстрирует типичную неявную итерацию при помощи цикла:
```
 for value in sequence:
     print value
```
Словари языка Python также могут быть перебраны напрямую с возвратом словарных ключей. Или метод items словаря может быть перебран, когда он дополняет связанный ключ, а значение этой пары является кортежом:
```
for key in dictionary:
    value = dictionary[key]
    print key, value
for key, value in dictionary.items():
    print key, value
```
Для любого перечисляемого типа цикла или класса встроенная функция iter() создает итератор. Итератор реализует метод next(), который возвращает следующий элемент в контейнере. Когда элементов больше не остается вызывается ошибка StopIteration. Следующий пример демонстрирует соответствующую циклическую итерацию при помощи явных итераторов:
```
it = iter(sequence)
while True:
    try:
        value = it.next()
    except StopIteration:
        break
    print value
```
В следующем примере итератором является сам файловый объект f, обеспечивающий доступ к файлу как к последовательности строк:

 f = open("README")                    # открытие файла
 print f.next()                        # следующее значение итератора - очередная строка файла
 print sum(len(line) for line in f)    # сумма длин всех остальных строк файла
```

# игра "Жизнь"
https://ru.wikipedia.org/wiki/%D0%96%D0%B8%D0%B7%D0%BD%D1%8C_%28%D0%B8%D0%B3%D1%80%D0%B0%29

## классические правила:

- Время дискретно.
- Игровое поле - плоскость, состоящая из клеток, у каждой клетки восемь соседей.
- Клетки могут находится в двух состояниях: живом или мертвом. Совокупность живых клеток называется поколением.
- В процессе игры каждая клетка может неограниченное количество раз - переходить из одного состояния в другое.

Правила перехода тоже не отличаются сложностью:

- Каждое следующее поколение рассчитывается на основе предыдущего.
- Мертвая клетка оживает, если рядом с ней находится ровно 3 живые клетки.
- Живая клетка продолжает жить, если рядом с ней находится 2 или 3 живые клетки.

Начать лучше с самого прямолинейного способа. Он выглядит примерно так:

1. Создается двумерный массив из булевых значений, где True бы означал наличие живой клетки, а False - мертвой.
2. Генерируется новый массив.
3. Для каждой клетки определяется число живых соседей и на основании этого определяется, будет ли она жить в новом поколении.
4. Новый массив записывается на место старого.
5. Происходит возврат к пункту 2.
Обычное в этом месте появляется потребность определять соседей клетки для реализации пункта 3. Поскольку сейчас мы имеем игровое поле, представленное в виде массива - есть риск выйти за его пределы. Есть несколько способов этого избежать:

- Отбрасывать в функции все обращения к i, j < 0 и i >= n, j >= m (где m и n - размер строки и столбца соответственно).
- Замкнуть поле на само себя - все обращения к клеткам из предыдущего пункта считать обращением к клетке с другой стороны поля. Т.е i < 0 будет обращением к m - i, i > m будет обращением к клетке m - i. Для j формулы аналогичны.
- Оградить игровое поле со всех сторон элементами, обозначающими его границу. Такие элементы физически не являются ни мертвым, ни живыми, но при подсчете числа живых соседей считаются мертвыми.

Алгоритм хоть и прост для понимания, но имеет ряд недостатков:

- Имеет линейное от размеров поля время работы.
- Двойное потребление памяти (нужно хранить предыдущее поколение + новое).
- Требует много кода для реализации.


## оптимизация
Можно уменьшить время вычисления следующего поколения с помощью списка значений, которые могут измениться на следующем шаге. А измениться могут только две категории клеток: живые и их соседи. Введение еще одной структуры немного усложнит код, увеличит потребление памяти до тройного в худшем случае, но время работы станет линейным только в худшем случае.

## Кардинальная оптимизация с переосмыслением
состояние поля можно выразить просто списком живых клеток. 
Зная только координаты живых клеток мы можем воссоздать поле в изначальном состоянии. Хранить состояние соседних с живыми клеток нам тоже не требуется - поскольку состояний у клеток всего два (жива-мертва) - все, кто не живы, мертвы, а получить координаты соседей по координатам клетки тоже достаточно просто. Плюсы этого варианта достаточно заманчивы:

- Экономия памяти. Нам не нужно хранить все поле целиком.
- Время такое же, как и в предыдущем разделе.
- Динамичность игрового поля. Размеры поля можно менять на протяжении игры в зависимости от расположения живых клеток.
- Алгоритм очень легко параллелится. Можно создать несколько потоков, которые бы принимали список живых клеток и координаты рассматриваемой клетки. Результат работы потоков склеивается и получается новый список живых клеток.

Все начинается с функции, генерирующей новое поколение клеток на основе списка живых клеток предыдущего поколения:
```
def new_step(alive_cons):
    board = itertools.chain(*map(get_neighbors, alive_cons))
    new_board = set([con
                 for con in board
                 if is_alive_con(con, alive_cons)])
    return list(new_board)
```
Запутанная конструкция board = itertools.chain(*map(get_neighbors, alive_cons)) всего лишь сохраняет в переменной board список всех живых ячеек и их соседей. Теперь настала очередь функции is_alive_con.
```
def is_alive_con(con, alive_cons):
    alive_neighbors = calculate_alive_neighbors(con, alive_cons)
    if (alive_neighbors == 3 or
            (alive_neighbors == 2 and con in alive_cons)):
        return True
    return False
```
В следующей реализованы правила перехода клетки из одного состояния в другое.
```
def calculate_alive_neighbors(con, alive_cons):
    return len(filter(lambda x: x in alive_cons,
                      get_neighbors(con)))
```
Осталось рассмотреть самое важное - функцию, которая возвращает список всех соседей клетки на основе ее координат.
```
def get_neighbors(con):
x, y = con
neighbors = [(x + i, y + j)
             for i in xrange(-1, 2)
             for j in xrange(-1, 2)
             if not i == j == 0]
return neighbors
```
Здесь нет необходимости проверять корректность координат клеток соседей - некорректные координаты (приводящие к обращению за пределы поля) и так не должны будут встретиться в списке живых. Корректность имеет смысл проверять уже после создания нового поколения. 
для этого реализованы две функции - одна проверяет корректность координат клетки, другая делает нечто с "неправильными" - в этой реализации просто отбрасывает все некорректные значения:
```
def is_correct_con(size, con):
x, y = con
return all(0 <= coord <= size - 1 for coord in [x, y])


def correct_cons(size, cons):
    return filter(lambda x: is_correct_con(size, x), cons)
```
# alive
```
import itertools


def get_board(size, alive_cons):
    return [[1 if (i, j) in alive_cons else 0
             for j in xrange(size)]
            for i in xrange(size)]


def get_neighbors(con):
    x, y = con
    neighbors = [(x + i, y + j)
                 for i in xrange(-1, 2)
                 for j in xrange(-1, 2)
                 if not i == j == 0]
    return neighbors


def calculate_alive_neighbors(con, alive_cons):
    return len(filter(lambda x: x in alive_cons,
                      get_neighbors(con)))


def is_alive_con(con, alive_cons):
    alive_neighbors = calculate_alive_neighbors(con, alive_cons)
    if (alive_neighbors == 3 or
            (alive_neighbors == 2 and con in alive_cons)):
        return True
    return False


def new_step(alive_cons):
    board = itertools.chain(*map(get_neighbors, alive_cons))
    new_board = set([con
                     for con in board
                     if is_alive_con(con, alive_cons)])
    return list(new_board)


def is_correct_con(size, con):
    x, y = con
    return all(0 <= coord <= size - 1 for coord in [x, y])


def correct_cons(size, cons):
    return filter(lambda x: is_correct_con(size, x), cons)


def print_board(board):
    for line in board:
        print line
    print


def main():
    size = 6
    board = [(1, 2), (2, 3), (3, 1), (3, 2), (3, 3),(3,4)]
    print_board(get_board(size, board))
    for _ in xrange(10):
        board = correct_cons(size, new_step(board))
        print_board(get_board(size, board))


if __name__ == '__main__':
    main()

```



## модуль functools и возможность частичного применения функций:
```
from  functools import partial
def myfun(a, b): return a + b

myfun1 = partial(myfun, 1)
print myfun1(2)
3
```


# Ленивые вычисления

Ленивые вычисления можно организовать в Python несколькими способами, используя различные механизмы:

простейшие логические операции or и and не вычисляют второй операнд, если результат определяется первым операндом


(Python 2.5) if-выражение имеет «ленивую» семантику (вычисляется только тот операнд, который нужен)

Пример, который иллюстрирует работу if-выражения. С помощью оператора print можно проследить, какие функции реально вызывались:
```
def f():
    print "f"
    return "f"

def g():
    print "g"
    return "g"

f() if True else g()
f
'f'
f() if False else g()
g
'g'

```

## Пример ленивого вычисления чисел Фибонначи:

$ cat fib.py
```
from itertools import chain, islice, izip, starmap, imap

def fib():
    for i in chain([1,1], starmap(lambda x,y: x+y, izip(fib(), islice(fib(), 1, None)))):
        yield i

print list(islice(fib(), 0, 10))

$ python fib.py
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]


```
# Чистые функции и ленивый компилятор
Императивные функции могут изменять внешние (глобальные) переменные, и это значит, что функция может возвращать различные значения при одних и тех же значениях аргумента на разных стадиях выполнения программы.

Такое утверждение совсем не подходит для функциональной парадигмы. Здесь функции рассматриваются как математические, зависящие только от аргументов и других функций, за что они и получили прозвище «чистые функции».

Чистая функция – это функция без побочных эффектов, а значит, она не зависит от своего окружения и не изменяет его состояния.

Применение чистых функций дает нам ряд преимуществ:

- Во-первых, если функции не зависят от переменных окружения, то мы уменьшаем количество ошибок, связанных с нежелательными значениями этих самых переменных. Вместе с количеством ошибок мы уменьшаем и время отладки программы, да и дебагить такие функции гораздо проще.

- Во-вторых, если функции независимы, то компилятору есть, где разгуляться. Если функция зависит только от аргументов, то ее можно посчитать только один раз. В следующие разы можно использовать кэшированное значение. Также, если функции не зависят друг от друга, их можно менять местами и даже автоматически распараллеливать.

Для увеличения производительности в ФП также используются ленивые вычисления. Яркий пример:
```
print length([5, 4/0, 3+2])
```
По идее, на выходе мы должны получить ошибку деления на ноль. Но ленивый компилятор питона просто не станет вычислять значения каждого элемента списка, так как его об этом не просили. Нужна длина списка – пожалуйста!
Те же принципы используются и для других языковых конструкций.


## Lazy Traversal of Directed Graphs
```

def graphWalker(node, getChildren, toEvaluate, backPack = None):
    rr = toEvaluate(node, backPack)
    yield rr[0]
    for child in getChildren(node):
        for result in graphWalker(child, getChildren, toEvaluate, rr[1]):
            yield result

import os
import stat
       
def walkTest(root = os.getcwd(), recursionLimit = 3):
    
    def te(node, rl):
        root, visitedNodes, name = node[:3]
        if rl < 0: raise StopIteration
        return (
                os.sep.join(visitedNodes + [name])[1:],
                rl - 1
                )
    
    def absPath(node):
        return os.sep.join(
                               [node[0]] + node[1] + [node[2]]
                               )
    
    def isdir(path):
        """
        @param path the absolute (?) path of the file
        """
        return stat.S_ISDIR(os.stat(
                                    path
                                    )[stat.ST_MODE])
        
    def gc(node):
        
        root, visitedNodes, name, depth = node
        
        ab = absPath(node)
        if not isdir(ab): return []
        

        return [
                (
                 root,
                 visitedNodes + [name],
                 cc,
                 depth + 1
                 )
                for cc in
                os.listdir(ab)]

    return graphWalker((root, [], "", 0), gc, te, recursionLimit)

if __name__ == "__main__":
    for rr in walkTest():
        print rr
    
```