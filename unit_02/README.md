# Структура программы 

Первую строку программы необходимо оформить как комментарий, в котором указывается кодировочная таблица («кодировка») файла

## Пример простейшей программы: 
```
# -*- coding: utf-8 -*- 
name=raw_input ( ’ Как тебя зовут? ␣ ’ ) 
print ’Здравствуй , ’ , name ,’ ! ’ 

```
Для выполнения программы из командной строки следует вызвать интерпретатор Python, указав в качестве аргумента имя файла с программой, например python 
```
my_program.py 
```
В IDLE для этого нужно в окне редактора нажать клавишу F5.

# Ввод и вывод в Python 

## Диалоговый режим 

При работе с интерактивными оболочками или в процессе организации взаимодействия программы с пользователем («диалога») для ввода чисел и, соответственно, определения значений переменных будем использовать функции input() и raw_input(). 

В качестве аргумента этих функции рекомендуется использовать строку-подсказку (приглашение для ввода), в которой кратко описывается, какие данные и как необходимо сообщить программе. 

Если в строке-подсказке используются символы кириллицы (русские буквы), то нужно предварительно указать кодировочную таблицу. 

Строка-подсказка может быть в двойных или в одиночных кавычках. Для выполнения операций input() или raw_input() интерпретатор останавливает программу и после строки-подсказки требуется ввести требуемое значение переменной и нажать ENTER. Если строка подсказки отсутствует, будет показан курсор оболочки в пустой строке окна выполнения. Если требуется ввести несколько значений, их нужно вводить через запятую и нажимать ENTER только после последнего введённого значения. 

При использовании функции input() числовые значения пишутся как обычно, а строковые нужно писать в кавычках (двойных или одиночных). 

Примеры: 
```
a=input()
a=input(’Введите значение␣ a : ’ ) 
a,b,c=input(’Введите длины сторон треугольника через запятую : ’ ) 
t =(a,b,c,d)=input(’Введите элементы : ’)
```
Для ввода только строковых значений в Python используется функция 
raw_input(). Её особенности во многом совпадают с функцией input (). Есть одна деталь — строковые значения при их вводе не нужно заключать в кавычки. Если с помощью raw_input() вводить числа, они преобразуются в строки. 
Примеры: 
```
name=raw_input ( ’ Как тебя зовут?  ’ )
name 
age=raw_input ( ’ Сколько тебе лет?  ’ )
age
```
Для вывода результатов работы используется инструкция print, которая не яв 
ляется функцией. Использование инструкции (команды) print позволяет производить вычисления «на лету» и выводить одновременно (одним ператором) 
строки и числа. 

Примеры: 
```
print ’== −s t r o k a −==’
```
# вывод текста 
```
t =(a,b,c,d )=input(’Введите элементы : ’ )
print t
```
При выводе нескольких значений через запятую print автоматически добавляет 
проблеы между значениями переменных. 
```
t=(a,b,c,d) = input(’Введите элементы : ’ )
t1 = (1,2,3 )
print ’Итоговый␣кортеж ’ , t+t1
```

# Справочная система и получение информации о Python 

Основой справочной системы Python является сам Python и команда help, которую можно использовать в интерактивной оболочке. 

help
Type help() for interactive help, or help(object) for help about object. 


help> 

Из результатов работы команды help() можно узнать, во-первых, версию Pyhton, во-вторых, адрес сайта с документацией, а в-третьих, получить названия основных разделов справки — модули Python («modules»), ключевые слова Python («keywords») и темы справки («topics»). 

После выполнения команды help() Python переходит в режим интерактивной справки, соответственно изменяя приглашение оболочки. 
Попробуем узнать список ключевых слов, чтобы случайно не использовать их в качестве имён переменных. 

help> keywords
Here is a list of the Python keywords. Enter any keyword to get more help. 
```
and 
else 
import 
raise 
assert 
except 
in 
return 
break 
exec 
is 
try 
class 
finally 
lambda 
while 
continue 
for 
not 
yield 
def 
from 
or 
del 
global 
pass 
elif 
if 
print 
```
help > quit()

Для выхода из интерактивной справки используется команда quit. Справку по Python в виде гипертекста и тоже на английском языке можно получить, открыв в любом браузере файл /usr/share/doc/python-doc-x.y.z/index.html, где x.y.z — версия Python. 

# Типы данных и операции с ними 

## Числа 

Числа в Python могут быть обычными целыми (тип int), длинными целыми (тип long), вещественными (тип float) и комплексными 

Для преобразования чисел из вещественных в целые и наоборот в Python определены функции int() и float(). Например, int(12.6) даст в результате 12, а float(12) даёт в результате 12.0 (десятичный разделитель — точка). 
Кроме того, в Python для операций с числами используются функции abs() (вычисление абсолютного значения — модуля, abs(−3) → 3), pow() (возведение в степень, pow(2,3) → 8), divmod() (вычисление результата целочисленного деления и остатка, divmod(17,5) → (3,2)) и round() (округление, round(100.0/6) → 17.0). 

Эти функции являются «встроенными», что означает, что для их использования нет необходимости подключать дополнительные модули. Все прочие функции для работы с числами (математические), такие как вычисление квадратного корня, синуса и пр. требуют подключения модуля math. 

## Числа с плавающей точкой 
Тип данных float может вызываться как функция - без аргументов возвращается число 0.0, с аргументом типа float возвращается копия аргумента, а с аргументом любого другого типа предпринимается попытка выполнить преобразование указанного объекта в тип float. При преобразовании строки аргумент может содержать либо простую форму записи числа с десятичной точкой, либо экспоненциальное представление числа. При выполнении операций с числами типа float может возникнуть ситуация, когда в результате получается значение NaN (not a number - не число) или «бесконечность». 

Ниже приводится пример простой функции, выполняющей сравнение чисел типа float на равенство в пределах машинной точности: 
```
def equal_float(a, b): 
    return abs(a - b) <= sys.float_info.epsilon 
```
Чтобы воспользоваться этой функцией, необходимо импортировать модуль sys. Объект sys.float_info имеет множество атрибутов. Так, sys.float_info. epsilon хранит минимально возможную разницу между двумя числами с плавающей точкой.  

(Epsilon - это традиционное название чисел такого рода.) Тип float в языке Python обеспечивает надежную точность до 17 значащих цифр. 
Если ввести sys.float_info в среде IDLE, будут выведены все атрибуты этого объекта, куда входят минимальное и максимальное значения чисел с плавающей точкой, которые могут быть представлены машиной. А если ввести команду help(sys.float_info), будет выведена некоторая информация об объекте sys.float_info. 

Числа с плавающей точкой можно преобразовать в целые числа с помощью функции int(), которая возвращает целую часть и отбрасывает дробную часть, или с помощью функции round(), которая учитывает величину дробной части, или с помощью функций math.floor() и math.ceil(), которые округляют вверх или вниз до ближайшего целого. Метод float.is_integer() возвращает значение True, если дробная часть числа равна 0. Представление дробной части числа можно получить с помощью метода float.as_integer_ratio(). Например, пусть х = 2.75, тогда метод х.as_integer_ratio() вернет (11, 4). 

Преобразование целых чисел в тип float можно выполнить с помощью функции float(). 

Числа с плавающей точкой также могут быть представлены в виде строк в шестнадцатеричном формате с помощью метода float.hex(). 
Обратное преобразование может быть выполнено с помощью метода float.fromhex() Например: 

```
s = 14.25.hex() # str s == '0x1.c800000000000p+3' 
f = float.fromhex(s) # float f == 14.25 
t = f.hex() # str t == '0x1.c800000000000p+3'
```
Экспонента отмечается с помощью символа р (power - «степень»), а не е, так как символ е представляет допустимую шестнадцатеричную цифру. 
```
import math 

math.pi * (5 ** 2) 

math.hypot(5, 12) 

math.modf(13.732) 
```
Функция math.hypot() вычисляет расстояние от начала координат до точки (х, у) и дает тот же результат, что и выражение math.sqrt((x ** 2) + (У ** 2)). 

идентификатор не должен совпадать с каким-либо из ключевых слов языка Python, поэтому мы не можем использовать имена, которые приводятся в dir()  ['__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__'] 
```
dir(__builtins__) 
```
## Модуль keyword

keyword.kwlist - список всех доступных ключевых слов.
keyword.iskeyword(строка) - является ли строка ключевым словом.

## Ключевые слова
```
False - ложь.
True - правда.
None - "пустой" объект.
and - логическое И.
with / as - менеджер контекста.
assert условие - возбуждает исключение, если условие ложно.
break - выход из цикла.
class - пользовательский тип, состоящий из методов и атрибутов.
continue - переход на следующую итерацию цикла.
def - определение функции.
del - удаление объекта.
elif - в противном случае, если.
else - см. for/else или if/else.
except - перехватить исключение.
finally - вкупе с инструкцией try, выполняет инструкции независимо от того, было ли исключение или нет.
for - цикл for.
from - импорт нескольких функций из модуля.
global - позволяет сделать значение переменной, присвоенное ей внутри функции, доступным и за пределами этой функции.
if - если.
import - импорт модуля.
in - проверка на вхождение.
is - ссылаются ли 2 объекта на одно и то же место в памяти.
lambda - определение анонимной функции.
nonlocal - позволяет сделать значение переменной, присвоенное ей внутри функции, доступным в объемлющей инструкции.
not - логическое НЕ.
or - логическое ИЛИ.
pass - ничего не делающая конструкция.
raise - возбудить исключение.
return - вернуть результат.
try - выполнить инструкции, перехватывая исключения.
while - цикл while.
yield - определение функции-генератора.
```
можно воспользоваться инструментом проверки программного кода на языке Python, таким как PyLint (www.logilab.org/project/name/pylint). 

Все битовые операторы (|, ~, &, >> и <<) имеют соответствующие комбинированные операторы присваивания (| =, ~=, &=, «= и »=), где выражение i op= j является логическим эквивалентом выражения i = i op j в случае, когда обращение к значению i не имеет побочных эффектов. 

Если имеется необходимость хранить множество флагов, способных иметь всего два состояния, можно использовать единственное целое число и проверять значения отдельных его битов с помощью битовых операторов. То же самое можно делать менее компактным, но более удобным способом, воспользовавшись логическим типом. 

- bin(i)      Возвращает двоичное представление целого числа i в виде строки, например, bin(1980) == 'ОЫПЮПИОО' 

- hex(i)      Возвращает шестнадцатеричное представление целого числа i в виде строки, например, hex( 1980) == '0x7bc' 

- int(x)      Преобразует объект х в целое число; в случае ошибки во время преобразования возбуждает исключение ValueError, а если тип объекта х не поддерживает преобразование в целое число, возбуждает исключение ТуреЕггог. Если х является числом с плавающей точкой, оно преобразуется в целое число путем усечения дробной части. 

- int(s, base)    Преобразует строку s в целое число, в случае ошибки возбуждает исключение ValueError. Если задан необязательный аргумент base, он должен быть целым числом в диапазоне от 2 до 36 включительно. 
oct(i)      Возвращает восьмеричное представление целого числа i в виде строки, например, oct( 1980) == '0о3674" 

Если вам действительно необходимо обеспечить высокую точность, можно использовать числа типа decimal.Decimal. Эти числа обеспечивают уровень точности, который вы укажете (по умолчанию 28 знаков после запятой), и могут точно представлять периодические числа, такие как 0.11, но скорость работы с такими числами существенно ниже, чем с обычными числами типа float. Вследствие высокой точности числа типа decimal.Decimal прекрасно подходят для производства финансовых вычислений. 

```
decimal.Decimal(2.99)
```

# Строки в Python  — это последовательности символов (codepoints)

- нет разницы между одинарными и двойными кавычками, 
- символ строки это тоже строка, 
- можно использовать тройные кавычки для многострочных блоков текста. 
- Для форматирования строк следует использовать метод format, но полезно знать также про синтаксис с использованием оператора % .

## Строковые литералы

Можно использовать двойные или одинарные кавычки: 
```
"foobar" == 'foobar' 

```
Для многострочных блоков текста используют тройные кавычки: 
```
"""foo 
... bar""" 

```
Подряд идущие строковые литералы “склеиваются”: 

```
"foo" "bar" 

str1 = 'First line.\nSecond line.'  # \n means newline 
print(str1) 
print('C:\some\name')  # here \n means newline! 
print r'C:\some\name'  # note the r before the quote 

print """\ 
Usage: thingy [OPTIONS] 
     -h                        Display this usage message 
     -H hostname               Hostname to connect to 
"""
```

Если потребуется записать длинный строковый литерал, занимающий две или более строк, но без использования тройных кавычек, то можно использовать один из приемов: 

```
#  -*- coding: utf-8 -*- 
t = "Это не самый лучший способ объединения двух длинных строк, " \ 
    "потому что он основан на использовании неуклюжего экранирования" 
s = ("Это отличный способ объединить две длинные строки, потому что он основан на конкатенации строковых литералов.") 
print t 
print s 

```


# Calculator Program 1.py
```

# Program make a simple calculator that can add, subtract, multiply and divide using functions

# define functions
def add(x, y):
   """This function adds two numbers"""

   return x + y

def subtract(x, y):
   """This function subtracts two numbers"""

   return x - y

def multiply(x, y):
   """This function multiplies two numbers"""

   return x * y

def divide(x, y):
   """This function divides two numbers"""

   return x / y

# take input from the user
print("Select operation.")
print("1.Add")
print("2.Subtract")
print("3.Multiply")
print("4.Divide")

choice = input("Enter choice(1/2/3/4):")

num1 = int(input("Enter first number: "))
num2 = int(input("Enter second number: "))

if choice == '1':
   print(num1,"+",num2,"=", add(num1,num2))

elif choice == '2':
   print(num1,"-",num2,"=", subtract(num1,num2))

elif choice == '3':
   print(num1,"*",num2,"=", multiply(num1,num2))

elif choice == '4':
   print(num1,"/",num2,"=", divide(num1,num2))
else:
   print("Invalid input")

```

- def operator
```
def function_name(parameter_1,parameter_2):
    {this is the code in the function}
    {more code}
    {more code}
    return {value to return to the main program}
{this code isn't in the function}
{because it isn't indented}
#remember to put a colon ":" at the end
#of the line that starts with 'def'
```
- return
```
def function_name(parameter_1,parameter_2):
    {this is the code in the function}
    {more code}
    {more code}
    return {value to return to the main program}
```

## Passing Parameters to functions

- Defining functions with parameters
```
def function_name(parameter_1,parameter_2):
    {this is the code in the function}
    {more code}
    {more code}
    return {value (e.g. text or number) to return to the main program}
```
- how parameters work
```
def funnyfunction(first_word,second_word,third_word):
    print "The word created is: " + first_word + second_word + third_word
    return first_word + second_word + third_word

```

## menu 
```
def menu():
   print("Select operation.")
   print("1.Add")
   print("2.Subtract")
   print("3.Multiply")
   print("4.Divide")
   choice = input("Enter choice(1/2/3/4):")
   return choice

choice = menu()


def menu():
   print("Select operation.")
   print("1.Add")
   print("2.Subtract")
   print("3.Multiply")
   print("4.Divide")
   return input("Enter choice(1/2/3/4):")
   
choice = menu()
```

## Else 3.py

```
def myhelp():
   print """\ 
   Usage operation: 
        '0'                        Display this usage message 
        '1'                        Add 
        '2'                        Subtract 
        '3'                        Multiply 
        '4'                        Divide 
        """
def menu():
   print("Select operation.")
   print("0.Help")
   print("1.Add")
   print("2.Subtract")
   print("3.Multiply")
   print("4.Divide")
   
   return input("Enter choice(0/1/2/3/4):")
...
else:
   myhelp()

```

## Экранирование последовательности и “сырые” строки
В языке Python символ перевода строки интерпретируется как завершающий символ инструкции, но не внутри круглых скобок (()), квадратных скобок ([ ]), фигурных скобок ({}) и строк в тройных кавычках. 

### Символы перевода строки  
мы можем включать символы перевода строки в любые строковые литералы с помощью экранированной последовательности \п. 

4.py

```
def menu():
   print("Select operation:\n")

   print("0.Help")
   print("1.Add")
   print("2.Subtract")
   print("3.Multiply")

   print("4.Divide\n")

   return input("Enter choice(0/1/2/3/4):")
```

## Экранированные последовательности в языке Python 

- \перевод_строки Экранирует (то есть игнорирует) символ перевода строки 
- \\ Символ обратного слеша (\) 
- \' одинарная кавычка 
- \" двойная кавычка 
- \t символ вертикальной табуляции 
- \n символ переноса строки 
- \xhh символ с HEX кодом hh 
- \а Символ ASCII «сигнал» (bell, BEL) 
- \b Символ ASCII «забой» (backspace, BS) 
- \f Символ ASCII «перевод формата» (formfeed, FF) 
- \N{название} Символ Юникода с заданным названием 
- \ооо Символ с заданным восьмеричным кодом 
- \r Символ ASCII «возврат каретки» (carriage return, CR) 
- \t Символ ASCII «табуляция» (tab, TAB) 
- \uhhhh Символ Юникода с указанным 16-битовым шестнадцатеричным значением 
- \Uhhhhhhhh Символ Юникода с указанным 32-битовым шестнадцатеричным значением 
- \v Символ ASCII «вертикальная табуляция» (vertical tab, VT) 
- \xhh Символ с указанным 8-битовым шестнадцатеричным значением 

Полный список поддерживаемых последовательностей можно прочитать в 
документации http://bit.ly/escape-sequences

# Преобразование объекта в строку
В Python 3 есть три различных по смыслу способа преобразовать объект в строку: 
- str возвращает человекочитаемое представление объекта, 
- repr возвращает представление объекта, по которому можно однозначно восстановить его значение, 
- ascii аналогичен repr по смыслу, но возвращаемая строка должна содержать только символы ASCII. 

Примеры: 
```
str("я строка") 

repr("я строка") 

ascii("я строка") 

unicode("я строка") 

```

# str unicide 5.py

```
def menu():
   print("Select operation:\n")
   print("0.Help")
   print("1.Add")
   print("2.Subtract")
   print("3.Multiply")
   print("4.Divide\n")
   return input("Enter choice(0/1/2/3/4):")
   # return str(input("Enter choice(0/1/2/3/4):"))
   # return unicode(input("Enter choice(0/1/2/3/4):"))

choice = menu()
# choice = unicode(menu())
# choice = str(menu())

num1 = int(input("Enter first number: "))
num2 = int(input("Enter second number: "))

if unicode(choice) == '0':
   myhelp()

elif str(choice)  == '1':
   print(num1,"+",num2,"=", add(num1,num2))

elif choice == '2':
   print(num1,"-",num2,"=", subtract(num1,num2))

elif choice == '3':
   print(num1,"*",num2,"=", multiply(num1,num2))

elif choice == '4':
   print(num1,"/",num2,"=", divide(num1,num2))

else:
   myhelp()


def myhelp():
   print """ 
   Usage operation: 
        0                        Display this usage message 
        1                        Add 
        2                        Subtract 
        3                        Multiply 
        4                        Divide 
        """
```

## 6.py

```
if choice == '0':
   myhelp()

else:
   num1 = int(input("Enter first number: "))
   num2 = int(input("Enter second number: "))

   if choice == '1':
      print(num1,"+",num2,"=", add(num1,num2))

   elif choice == '2':
      print(num1,"-",num2,"=", subtract(num1,num2))

   elif choice == '3':
      print(num1,"*",num2,"=", multiply(num1,num2))

   elif choice == '4':
      print(num1,"/",num2,"=", divide(num1,num2))

   else:
      myhelp()

```

## Форматирование строк: 

s.format(...) Возвращает копию строки s, отформатированную в соответствии с заданными аргументами. 

### Форматирование строк с помощью метода str.format() 
В Python есть два способа форматирования строк. Первый использует метод format : 
```
"{}, {}, how are you?".format("Hello", "Sally") 

"Today is October, {}th.".format(8) 

```
- {} обозначает место, в которое будет подставлен позиционный аргумент. 

- Внутри {} можно опционально указать способ преобразования объекта в строку и спецификацию формата.

- Для преобразования объекта в строку используются первые буквы соответствующих функций: 

```
"{!s}".format("я строка") # str 

"{!r}".format("я строка") # repr 

"{!a}".format("я строка") # ascii 

"'\\u044f \\u0441\\u0442\\u0440\\u043e\\u043a\\u0430'" 
```

### Форматирование строк: спецификация формата

Спецификация формата позволяет: 

- выровнять строку в “блоке” фиксированной длины, 
```
"{:~^16}".format("foo bar") 

```
- привести число к другой системе исчисления, 

```
"int: {0:d} hex: {0:x}".format(42) 

"oct: {0:o} bin: {0:b}".format(42) 
```
- потребовать наличие знака в строковом представлении числа и зафиксировать количество знаков до или после запятой. 
```
"{:+08.2f}".format(-42.42) 
```
- Комбинированный пример: 
```
"{!r:~^16}".format("foo bar") 
```

### Форматирование строк: позиционные и ключевые аргументы

- Внутри {} можно также явно указывать номер позиционного или имя ключевого аргумента: 
```
"{0}, {1}, {0}".format("hello", "kitty") 

"{0}, {who}, {0}".format("hello", who="kitty") 
```
- Если один из аргументов — контейнер, то при форматировании можно обращаться к его элементам по индексу или ключу: 

```
point = 0, 10 
"x = {0[0]}, y = {0[1]}".format(point) 

point = {"x": 0, "y": 10} 
"x = {0[x]}, y = {0[y]}".format(point) 
```

Каждое замещаемое поле идентифицируется именем поля в фигурных скобках. Если в качестве имени поля используется целое число, оно определяет порядковый номер аргумента, переданного методу str. formate). Поэтому в данном случае поле с именем 0 было замещено первым аргументом, а поле с именем 1 - вторым аргументом. Если бы нам потребовалось включить фигурные скобки в строку формата, мы могли бы сделать это, дублируя их, как показано ниже: 

```
 "{{{0}}} {1} ;-}}".format('I'm in braces", "I'm not") 
```
Если попытаться объединить строку и число, интерпретатор Python совершенно справедливо возбудит исключение ТуреЕггог. Но это легко можно сделать с помощью метода str.format(): 
```
record ="{0}{1}".format("The amount due is $", 200) 
print(record)
```

С помощью str.format() мы также легко можем объединять строки (хотя для этой цели лучше подходит метод str.join()): 
```
х = "three" 
s ="{0} {1} {2}" 
s = s.format("The", x, "tops") 
print(s) 
```

### Форматирование строк: олдскул

Второй способ форматирования строк в Python использует оператор % и внешне похож на printf : 

```
"%s, %s, how are you?" % ("Hello", "Sally") 

point = {"x": 0, "y": 10} 
"x = %(x)+2d, y = %(y)+2d" % point 
```

- Он менее выразителен и гибок чем format : 
- % — бинарный оператор, справа от него может быть один аргумент: кортеж или словарь, 
- нельзя использовать позиционный аргумент более одного раза, 
- нет синтаксиса для обращения к элементам контейнера или атрибутам объекта, 
- не предусмотрена возможность расширения, например, если потребуется форматировать длинные числа с плавающей точкой, то синтаксис "%8.2f" для них работать не будет.


## format 7.py

```
if choice == '0':
   myhelp()

else:
   num1 = int(input("Enter first number: "))
   num2 = int(input("Enter second number: "))

   if choice == '1':
      
      print('The sum of {0} and {1} is {2}'.format(num1, num2, add(num1,num2)))

   elif choice == '2':
      
      print('The subtract of {0} and {1} is {2}'.format(num1, num2, subtract(num1,num2)))

   elif choice == '3':
      
      print('The multiply of {0} and {1} is int: {2:d} hex: {2:x}'.format(num1, num2, multiply(num1,num2)))

   elif choice == '4':
      
      print('The divide of {0} and {1} is {2:+08.2f}'.format(num1, num2, divide(num1,num2)))

   else:
      myhelp()


```

# Строковые методы 
### Методы работы со строками: модификаторы регистра

- s.capitalize() Возвращает копию строки s с первым символом в верхнем регистре;

- s.swapcase() Возвращает копию строки s, в которой все символы верхнего регистра преобразованы в символы нижнего регистра, а все символы нижнего регистра - в символы верхнего регистра; 

- s.title() Возвращает копию строки s, в которой первые символы каждого слова преобразованы в символы верхнего регистра, а все остальные символы - в символы нижнего регистра; 

- s.upper() Возвращает копию строки s, в которой все символы приведены к верхнему регистру; 

s.zfill(w) Возвращает копию строки s, которая, если ее длина меньше величины w, дополняется слева нулями до длины w 


```
"foo bar".capitalize() 

"foo bar".title() 

"foo bar".upper() 

"foo bar".lower() 

"foo bar".title().swapcase() 

```

### Методы работы со строками: выравнивание
Группа методов, заканчивающихся на just , выравнивает строку в “блоке” фиксированной длины. При этом дополнительные позиции заполняются указанным 
символом: 
```
"foo bar".ljust(16, '~') 

"foo bar".rjust(16, '~') 

```
- s.center(width, char) Возвращает копию строки s, отцентрированную в строке с длиной width. Недостающие символы по умолчанию  заполняются пробелами или символами в соответствии с необязательным аргументом char (строка с длиной, равной 1); 

```
"foo bar".center(16, '~') 
```
В качестве символа по умолчанию используется пробел: 

Если длина “блока” меньше длины строки, то строка возвращается без изменений.

- s.count(t, start, end) Возвращает число вхождений строки t в строку s (или в срез строки s[start:end]) 

- s.encode(encoding, err) Возвращает объект типа bytes, представляющий строку в кодировке по умолчанию или в кодировке, определяемой аргументом encoding, с обработкой ошибок, определяемой необязательным аргументом err 

- s.expandtabs(size) Возвращает копию строки s, в которой символы табуляцш замещены пробелами с шагом 8 или в соответствии со значе нием необязательного аргумента size 
```
str2 = "interpreter the output" 
print(str2.capitalize()) 
print(str2.center(30)) 
print(str2.center(30,'#')) 
print(str2.count('the')) 
print(str2.count('the',3,20)) 
print(str2.encode()) 
print(str2.encode('utf-8')) 
print(str2.encode('ascii')) 
print(str2.endswith('output')) 
print(str2.endswith(('the', 'output'))) 
print(str2.startswith('inter'))
```

# Операторы и методы строк 
Поскольку строки относятся к категории неизменяемых последовательностей, все функциональные возможности, применимые к неизменяемым последовательностям, могут использоваться и со строками. Сюда входят оператор проверки на вхождение in, оператор конкатенации +, оператор добавления в конец +=, оператор дублирования * и комбинированный оператор присваивания с дублированием *=. 

# Оператор * обеспечивает возможность дублирования строки: 
```
s = «=» * 5 
```
мы можем также использовать комбинированный оператор присваивания с дублированием.
```
3 * 'un' + 'ium'


'Py' 'thon'

text = ('Put several strings within parentheses '
            'to have them joined together.')

```

Так как строки являются последовательностями, они являются объектами, имеющими «размер», и поэтому мы можем вызывать функцию lеп(), передавая ей строки в качестве аргумента. Возвращаемая функцией длина представляет собой количество символов в строке (ноль - для пустых строк). 

перегруженная версия оператора + для строк выполняет операцию конкатенации. В случаях, когда требуется объединить множество строк, лучше использовать метод str.join(). Метод принимает в качестве аргумента последовательность (то есть список или кортеж строк) и объединяет их в единую строку, вставляя между ними строку, относительно которой был вызван метод. Например: 

## С помощью метода join можно соединить любую последовательность строк: 
```
", ".join(["foo", "bar", "baz"]) 

", ".join(filter(None, ["", "foo"])) 

", ".join("bar") 
```
- Если последовательность содержит объекты другого типа, будет ошибка: 
```
", ".join(range(10)) 
```

```
str2 = ["In the interactive", "interpreter", "the output"] 
print("".join(str2)) 
print("-".join(str2)) 
print(" ".join(str2))
```
Первый пример является, пожалуй, наиболее типичным; он объединяет строки из списка, вставляя между ними единственный символ, в данном случае - пробел. Третий пример представляет собой операцию конкатенации в чистом виде - благодаря тому что метод вызывается относительно пустой строки, строки объединяются без добавления чего бы то ни было между ними. 

# 8.py

```
def myhelp():
   print " "*3 + "=" * 59
   print """   |                                                         | 
   | Usage operation:                                        |
   |     0                        Display this usage message | 
   |     1                        Add                        |  
   |     2                        Subtract                   | 
   |     3                        Multiply                   | 
   |     4                        Divide                     |
   |                                                         | """
   print " "*3 + "=" * 59

# take input from the user
def menu():
   print("Select operation:".upper().center(24, '~'))
   print("0.help".capitalize().ljust(16, '~'))
   print("1.add".title())
   print("2.Subtract")
   print("3.Multiply")
   print("4.Divide\n")
   print "=" * 21
      
   return str(input("enter choice(0/1/2/3/4):".capitalize()))
   
```

## Default choice 9.py
```
  File "8.py", line 50, in <module>
    choice = menu()
  File "8.py", line 47, in menu
    return str(input("enter choice(0/1/2/3/4):".capitalize()))
  File "<string>", line 0
    
    ^
SyntaxError: unexpected EOF while parsing
```
### raw_input
```
def menu():
   print("Select operation:".upper().center(24, '~'))
   print("0.help".capitalize().ljust(16, '~'))
   print("1.add".title())
   print("2.Subtract")
   print("3.Multiply")
   print("4.Divide\n")
   print "=" * 21
   choice = raw_input("enter choice(0/1/2/3/4):")
   return str(choice) if choice != '' else '0'
```



## Calculator program
```
# Program make a simple calculator that can add, subtract, multiply and divide using functions

# define functions
def add(x, y):
   """This function adds two numbers"""

   return x + y

def subtract(x, y):
   """This function subtracts two numbers"""

   return x - y

def multiply(x, y):
   """This function multiplies two numbers"""

   return x * y

def divide(x, y):
   """This function divides two numbers"""

   return x / y

def myhelp():
   print " "*3 + "=" * 59
   print """   |                                                         | 
   | Usage operation:                                        |
   |     0                        Display this usage message | 
   |     1                        Add                        |  
   |     2                        Subtract                   | 
   |     3                        Multiply                   | 
   |     4                        Divide                     |
   |                                                         | """
   print " "*3 + "=" * 59

# take input from the user
def menu():
   print("Select operation:".upper().center(24, '~'))
   print("0.help".capitalize().ljust(16, '~'))
   print("1.add".title())
   print("2.Subtract")
   print("3.Multiply")
   print("4.Divide\n")
   print("5.Quit calculator.py\n")
   print "=" * 21
   choice = raw_input("enter choice(0/1/2/3/4):")
   return str(choice) if choice != '' else '0'
   

loop = 1

while loop == 1:
   choice = menu()

   if choice == '0':
      myhelp()
   elif choice == '5':
         loop = 0
   else:
      num1 = int(input("Enter first number: "))
      num2 = int(input("Enter second number: "))

      if choice == '1':
         print('The sum of {0} and {1} is {2}'.format(num1, num2, add(num1,num2)))
      elif choice == '2':
         print('The subtract of {0} and {1} is {2}'.format(num1, num2, subtract(num1,num2)))
      elif choice == '3':
         print('The multiply of {0} and {1} is int: {2:d} hex: {2:x}'.format(num1, num2, multiply(num1,num2)))
      elif choice == '4':
         print('The divide of {0} and {1} is {2:+08.2f}'.format(num1, num2, divide(num1,num2)))
      
      else:
         myhelp()


print "Thankyou for using calculator.py!"

```

## Получение срезов строк 
отдельные элементы последовательности, а, следовательно, и отдельные символы в строках, могут извлекаться с помощью оператора доступа к элементам ([ ]). В действительности этот оператор намного более универсальный и может использоваться для извлечения не только одного символа, но и целых комбинаций (подпоследовательностей) элементов или символов, когда этот оператор используется в контексте оператора извлечения среза. 

Нумерация позиций символов в строках начинается с 0 и продолжается до значений длины строки минус 1. Однако допускается использовать и отрицательные индексы - в этом случае отсчет начинается с последнего символа и ведется в обратном направлении к первому символу. 

## Номера позиций символов в строке 
Отрицательные индексы удивительно удобны, особенно индекс -1, который всегда соответствует последнему символу строки. Попытка обращения к индексу, находящемуся за пределами строки (или к любому индексу в пустой строке), будет вызывать исключение IndexError. Оператор получения среза имеет три формы записи: 
```
seq[start] 
seq[start:end] 
seq[start;end:step] 
```
Значения start, end и step должны быть целыми числами (или переменными, хранящими целые числа). 

Вторая форма записи извлекает подстроку, начиная с элемента с индексом start и заканчивая элементом с индексом end, не включая его. При использовании второй формы записи (с одним двоеточием) мы можем опустить любой из индексов. Если опустить начальный индекс, по умолчанию будет использоваться значение 0. Если опустить конечный индекс, по умолчанию будет использоваться значение len(seq). Это означает, что если опустить оба индекса, например, s[: ], это будет равносильно выражению s[0:len(s)], и в результате будет извлечена, то есть скопирована, последовательность целиком. 

```
str1 ="In the interactive interpreter" 
str2 ="In the interactive interpreter, the output" 
print (str1[1]) 
print (str2[9]) 
print (str2[1:9]) 
print (str2[-9]) 
print (str2[0:]) 
print (str2[:-1]) 
print (str2[:]) 
print (str2[0:len(str2)])
```
## Извлечение срезов из последовательности 
Один из способов вставить подстроку в строку состоит в смешивании операторов извлечения среза и операторов конкатенации. Например: 

```
str2 ="In the interactive interpreter, the output" 
print (str2[:12] + 'test' + str2[12:])

```
Кроме того, поскольку текст «the» присутствует в оригинальной строке, тот же самый эффект можно было бы получить путем присваивания значения выражения print (str2[:12] + str2[3:6] + str2[12:]). 

Оператор конкатенации + и добавления подстроки += не особенно эффективны, когда в операции участвует множество строк. Для объединения большого числа строк обычно лучше использовать метод str.join(). 

```
str2 ="In the interactive interpreter, the output" 
print(str2[0:12:1]) 
print(str2[::3]) 
print(str2[::-3]) 
print(str2[20::-3]) 
print(str2[50::-1])
```
Операция извлечения элементов с определенным шагом часто применяется к последовательностям, отличным от строк, но один из ее вариантов часто применяется к строкам: 
```
s, s[: :-1] 
```
Шаг -1 означает, что будет извлекаться каждый символ, от конца до начала, то есть будет получена строка, в которой символы следуют в обратном порядке. 

## Методы работы со строками: проверка на вхождение
Вхождение построки идиоматично проверять с помощью операторов in и not in:
```
"foo" in "foobar" 

"yada" not in "foobar" 
```
- Можно также сравнить префикс или суффикс строки с данной строкой или строками: 
s.endswith(x, start, end) Возвращает True, если строка s (или срез строки s[start:end] оканчивается подстрокой х или любой из строк, если х - кортеж; в противном случае возвращает False. s.startswith (x, start, end) Возвращает True, если строка s (или срез строки s[ start: end]) начинается подстрокой х или любой из строк, если х - кортеж; в противном случае возвращает False. 
```
"foobar".startswith("foo") 

"foobar".endswith(("boo", "bar")) 
```

## Методы работы со строками: поиск подстроки

Найти индекс первого вхождения подстроки можно с помощью метода find : 

s.find(t, start, end) Возвращает позицию самого первого (крайнего слева) вхождения подстроки t в строку s (или в срез строки s[start:end]) если подстрока t не найдена, возвращается -1. Для поискa самого последнего (крайнего справа) вхождения следует использовать метод str.rfind(). 
```
"abracadabra".find("ra") 

"abracadabra".find("ra", 0, 3) 
```
- Метод index аналогичен find , но если искомая подстрока не найдена, он поднимает исключение: 
```
"abracadabra".index("ra", 0, 3) 
Traceback (most recent call last): 
File "<stdin>", line 1, in <module> 
ValueError: substring not found 
```
- Можно также поинтересоваться последним вхождением подстроки с помощью методов rfind и rindex .
s.index(t, start, end)  Возвращает позицию самого первого (крайнего слева) вхождения подстроки t в строку s (или в срез строки s[start\end]); если подстрока t не найдена, возбуждается исключение ValueError. Для поиска самого последнего (крайнего справа) вхождения следует использовать метод str.rfind() 

```
str2 = "interpreter the output" 
print(str2.find('the')) 
print(str2.find('the',5,20)) 
print(str2.find('the',5,8)) 
print(str2.rfind('the')) 
print(str2.index('the'))

```

## Методы работы со строками: предикаты
Методы-предикаты позволяют проверить строку на соответствие некоторому формату, например: 
```
"100500".isdigit() 

"foo100500".isalnum() 

"foobar".isalpha() 
```
- Другие полезные предикаты: 
```
"foobar".islower() 

"FOOBAR".isupper() 

"Foo Bar".istitle() 

"\r\n\t \r\n".isspace() 
```

- s.isalnum() Возвращает True, если строка s не пустая и содержит только алфавитно-цифровые символы 
- s.isalpha() Возвращает True, если строка s не пустая и содержит только алфавитные символы 
- s.isdecimal() Возвращает True, если строка s не пустая и содержит только символы Юникода, обозначающие цифры десятичной системы счисления 
- s.isdigit() Возвращает True, если строка s не пустая и содержит только символы ASCII, обозначающие цифры десятичной системы счисления 
- s.isidentifier() Возвращает True, если строка s не пустая и является допустимым идентификатором 
```
str2 = "interpreter the output" 
st1 = "123456" 
st2 = "Abcd" 
st4 = "ABC" 
st3 = "   " 
print(st1.isalnum()) 
print(st2.isalpha()) 
print(str2.isdigit()) 
print(str2.islower()) 
print(st1.isspace()) 
print(st3.isspace()) 
print(st2.isupper()) 
print(st4.isupper())
```
- s.islower() Возвращает True, если строка s имеет хотя бы один символ, который может быть представлен в нижнем регистре, и все такие символы находятся в нижнем регистре; 
- s.isnumeric() Возвращает True, если строка s не пустая и содержит только символы Юникода, используемые для обозначения чисел
- s.isprintable() Возвращает True, если строка s пустая или содержит только печатаемые символы, включая пробел, но не символ перевода строки 
- s.isspace() Возвращает True, если строка s не пустая и содержит только пробельные символы 
- s.istitle() Возвращает True, если строка s не пустая и имеет формат заголовка; 
- s.isupper() Возвращает True, если строка s имеет хотя бы один символ, который может быть представлен в верхнем регистре, и все такие символы находятся в верхнем регистре; 
- s.join(seq) Объединяет все элементы последовательности seq, вставляя между ними строку s (которая может быть пустой строкой)
- s.ljust(width, char)  Возвращает копию строки s, выровненной по левому краю, в строке длиной width. Недостающие символы по умолчанию заполняются пробелами или символами в соответствии с необязательным аргументом char (строка с длиной, равной 1). Для выравнивания по правому краю используйте метод str.rjust(), для выравнивания по центру - метод Str.center (); 
- s.lower() Возвращает копию строки s, в которой все символы приведены к нижнему регистру; 
- s.maketrans() Парный метод для str.translate(); подробности приводятся в тексте 

## Методы работы со строками: замена подстроки
- s.replace (t, u, n) Возвращает копию строки s, в которой каждое (но не более п, если этот аргумент определен) вхождение подстроки t замещается подстрокой
Метод replace заменяет все вхождения подстроки на заданную строку: 
```
"abracadabra".replace("ra", "**") 

"abracadabra".replace("ra", "**", 1) 
```

## Методы работы со строками: разделение
- s.split(t, n) Возвращает список строк, выполняя разбиение строки s не более чем п раз по подстроке t. Если число п не задано, разбиение выполняется по всем найденным подстрокам t. Если подстрока t не задана, разбиение выполняется по пробельным символам. Для выполнения разбиения строки, начиная с правого края, используйте метод str. rsplit - этот метод имеет смысл применять, когда задано число разбиений п, которое меньше максимального числа возможных разбиений 
Метод split разделяет строку на подстроки по указанному разделителю: 
```
"foo,bar".split(",") 

"foo,,,bar".split(",") 
```
- Несложно догадаться, что если разделитель не указан, то строка разделяется по пробелам. 
```
"\t foo bar \r\n 

```
- Метод partition возвращает кортеж из трех элементов: 
подстрока до вхождения разделителя, разделитель и подстрока после вхождения разделителя. 
- s.partition(t) Возвращает кортеж из трех строк - часть строки s перед самым первым (крайним слева) вхождением подстроки t, t и часть строки s после подстроки t; если подстрока t в строке s отсутствует, возвращаются строка s и две пустые строки. 
Для деления строки по самому последнему (крайнему справа) вхождению подстроки t, используйте метод str.Rpartition() 
```
"foo,bar,baz".partition(",") 

"foo,bar,baz".rpartition(",") 
```

- s.splitlines Возвращает список строк, выполняя разбиение строки s по символам перевода строки, удаляя их, если в аргументе f не задано значение True 

### Методы работы со строками: удаление символов
- s.strip(c/?ars) Возвращает копию строки s, из которой удалены начальные и завершающие пробельные символы (или символы, входящие в строку chars). 
- Метод str.lstrip() выполняет удаление только в начале строки  
- метод str. rstrip() - только в конце 
Группа методов, заканчивающихся на strip, удаляет все вхождения указанных символов слева, справа или с обоих концов строки: 
```
"]>>foo bar<<[".lstrip("]>") 

"]>>foo bar<<[".rstrip("[<") 

"]>>foo bar<<[".strip("[]<>") 
```
- По умолчанию удаляются все пробелы: 

Когда оператор проверки на вхождение in применяется к строкам, он возвращает True, если операнд слева является подстрокой операнда справа или равен ему. Когда необходимо точно определить позицию подстроки в строке, можно использовать два метода. Первый метод str.index() возвращает позицию подстроки в строке или возбуждает исключение ValueError, если подстрока не будет найдена. Второй метод str.find() возвращает позицию подстроки в строке или -1 в случае неудачи. Оба метода принимают искомую подстроку в качестве первого аргумента и могут принимать еще пару необязательных аргументов. 

Второй аргумент определяет позицию начала поиска, а третий - позицию окончания поиска. Какой из двух методов использовать - это лишь вопрос вкуса, хотя, если выполняется поиск нескольких вхождений одной и той же подстроки, программный код, использующий метод str.index(), выглядит более понятным, как показано ниже: 

```

def extract_from_tag(tag, line): 
    opener = '<' + tag + '>' 
    closer = '</' + tag + '>' 
    try: 
        i = line.index(opener) 
        start = i + len(opener) 
        j = line.index(closer, start) 
        return line[start:j] 
    except ValueError: 
        return None 
line = "<h2>interpreter the output</h2>" 
tag = 'h2' 
print(extract_from_tag(tag, line))

def extract_from_tag(tag, line): 
    opener = "<" + tag + ">" 
    closer = "</" + tag + ">" 
    i = line.find(opener) 
    if i != -1: 
        start = i + len(opener) 
        j = line.find(closer, start) 
        if j != -1: 
            return line[start:j] 
    return None 

```

Обе версии функции extract_from_tag() обладают одинаковым поведением. Например, вызов extract_from_tag(" red", "what a <red>rose</red> this is") возвращает строку «rose». В версии слева, основанной на обработке исключения, программный код, выполняющий поиск, отделен от программного кода, выполняющего обработку ошибок, а в версии справа программный код обработки строки смешивается с программным кодом обработки ошибок. Все методы- str.count(), str.endswith(), str.find(), str.rfind(), str.index(), str.rindex() и str.startswith() - принимают до двух необязательных аргументов: начальную и конечную позиции. 
Ниже приводятся два примера эквивалентностей (предполагается, что s — строка): 
```
s.count("m", 6) == s[6:].count("m") 
s.count('m", 5, -3) == s[5:-3].count("m") 
```
Как видите, строковые методы, принимающие начальную и конечную позиции, действуют со срезом строки, определяемым этими позициями. Теперь взгляните на еще одну пару эквивалентных фрагментов, на этот раз поясняющих действие метода str.partition(): 
```
i = s. rfind('/') 
if i == -1: 
result = s, "'", "'" 
else: 
result = s.rpartition('/') | result = s[:i], s[i], s[i + 1:] 
```
Фрагменты программного кода слева и справа не совсем эквивалентны, потому что фрагмент справа создает новую переменную i. Обратите внимание, что имеется возможность выполнять присваивание кортежей без лишних формальностей и что в обоих случаях выполняется поиск самого последнего (крайнего справа) вхождения символа /. Если предполагать, что s - это строка "/usr/local/bin/firefox", то оба фрагмента вернут один и тот же результат: ('/usr/local/bin', '/', 'firefox"). 

Метод str.endswith() (и str.startswith) может использоваться с единственным строковым аргументом, например s.startswith("From:"), или с кортежем строк. Ниже приводится инструкция, в которой используются методы str.endswith() и str.lower() для вывода имени файла, если он является файлом изображения в формате JPEG: 

```
filename = "image.jpg" 
if filename.lower().endswith((".jpg", ".jpeg")): 
    print(filename, "is a JPEG image'") 
```
Методы семейства is*, такие как isalphaO и isspace(), возвращают True, если строка, в контексте которой они вызываются, имеет по меньшей мере один символ, и все символы в строке соответствуют определенному критерию. Например: 
```
"917.5".isdigit(), "". isdigit(), "-2".isdigit(), "203". isdigit()« 

```
Удалить пробельные символы, находящиеся в начале строки, можно с помощью метода str.lstrip(), в конце строки - с помощью метода str.rstrip, а с обоих концов - с помощью метода str.strip(). Мы можем также передавать методам семейства *strip строки, в этом случае они удалят каждое вхождение каждого символа с соответствующего конца (или с обоих концов) строки. Например: 

```
s = "\t no parking " 
print(s.lstrip()) 
print(s.rstrip()) 
print(s.strip()) 
s = "<[unbracketed]>" 
print(s.strip("[](){><>")) 

```
Мы можем также замещать подстроки в строках, используя метод str.replace(). Этот метод принимает два строковых аргумента и возвращает копию строки, в контексте которой был вызван метод, где каждое вхождение строки в первом аргументе замещено строкой во втором аргументе. Если второй аргумент представляет собой пустую строку, это приведет к удалению всех вхождений строки в первом аргументе. Мы увидим примеры использования str. replace() и некоторых других строковых методов в примере csv2html.py в разделе «Примеры» в конце этой главы. 

Часто бывает необходимо разбить строку на список строк. Например, у нас может иметься текстовый файл с данными, в котором одной строке соответствует одна запись, а поля внутри записи отделяются друг от друга звездочками. Реализовать такое разбиение можно с помощью метода str.split(), передав ему строку, по которой выполняется разбиение, в виде первого аргумента и максимальное число разбиений в виде второго, необязательного аргумента. Если второй аргумент не указан, выполняется столько разбиений, сколько потребуется. Ниже приводится пример использования метода: 
```
# 16.py split 

record = "Leo Tolstoy*1828-8-28*1910-11-20" 
fields = record.split("*") 
print(fields) 
# ['Leo Tolstoy', '1828-8-28', '1910-11-20'] 

born = fields[1].split('-')  
# born 
# ['1828', '8', '28'] 

died = fields[2].split('-') 
print('lived about', int(died[0]) - int(born[0]), "years") 
# lived about 82 years 
```
Теперь мы можем с помощью метода str.split() выделить год рождения и год смерти и определить, сколько лет прожил Лев Толстой (плюс-минус один год): 
```
born = fields[1].split('-')  
# born 
# ['1828', '8', '28'] 

died = fields[2].split('-') 
print('lived about', int(died[0]) - int(born[0]), "years") 
# lived about 82 years 
```
Нам потребовалось использовать преобразование int(), чтобы преобразовать годы из строк в целые числа, но в остальном в этом фрагменте нет ничего сложного. Мы могли бы получить годы непосредственно из списка fields -например, year_born = int(fields[1]. split ("-")[0]). 

# Модуль string
В модуле string можно найти полезные при работе со строками константы: 
```
string.ascii_letters 

string.digits 

string.punctuation 

string.whitespace 

```
