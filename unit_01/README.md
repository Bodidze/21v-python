# 21v-python unit 01

# Самостоятельная установка среды 
## Установка Python на Windows
Скачивать python будем с официального сайта. Заходим на https://python.org/downloads/windows/, выбираем "latest python release" и python 3.

## Установка Python на linux системы (ubuntu, linux mint и другие)
Откройте консоль (обычно ctrl+alt+t). Введите в консоли:
python3
```
Python 3.4.0 (default, Apr 11 2014, 13:05:11)
[GCC 4.8.2] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>>
```
у вас уже стоит python  
В противном случае нужно установить пакет *python3*:
```
sudo apt-get install python3
```
### Python on Linux, Mac OS X, etc.
```
~/$ python
>>> 1 + 1
2
```
### Python on Windows
```
C:\> python
```
## Editing Python
Программный код на языке Python можно записать с помощью любого простого текстового редактора, который способен загружать и сохранять текст либо в кодировке ASCII, либо UTF-8. По умолчанию предполагается, что файлы с программным кодом на языке Python сохраняются в кодировке UTF-8, надмножестве кодировки ASCII, с помощью которой можно представить практически любой символ любого национального алфавита. 

Файлы с программным кодом на языке Python обычно имеют расширение .ру, хотя в некоторых UNIX-подобных системах (таких как Linux и Mac OS X) некоторые приложения на языке Python не имеют расширения, а программы на языке Python с графическим интерфейсом, в частности в Windows и Mac OS X, обычно имеют расширение .pyw.

## Как писать программы
### Интерактивный режим
В основном интерпретатор выполняет команды построчно: пишешь строку, нажимаешь Enter, интерпретатор выполняет ее, наблюдаешь результат.

Работать в интерактивном режиме в ОС Linux можно в консоли. Для этого следует выполнить команду python. Запустится интерпретатор, где сначала выведется информация об интерпретаторе. Далее, последует приглашение к вводу (>>>).
### Запустите интерпретатор Питона.
```
2 + 5
3 * (5 - 8)
2.4 + 3.0 / 2
и т.д.
```
Наберите подобные примеры в интерактивном режиме (в конце каждого нажимайте Enter). 

Ответ выдается сразу после нажатия Enter (завершения ввода команды).
Бывает, что в процессе ввода была допущена ошибка или требуется повторить ранее используемую команду. Чтобы не писать строку сначала, в консоли можно прокручивать список команд, используя для этого стрелки на клавиатуре.

Другой вариант работы в интерактивном режиме — это работа в среде разработки IDLE, у которой есть интерактивный режим работы. 

### IDLE (Integrated DeveLopment Environment)
— это интегрированная среда разработки на языке Python, созданная с помощью библиотеки Tkinter. Поставляется вместе с Python и благодаря использованию Tkinter может использоваться на многих платформах, среди которых Windows, Mac OS, Unix-подобные python.org/idle — официальный сайт IDLE

Среда IDLE обеспечивает ключевые возможности: 
- ввод выражений и программного кода на языке Python с получением результатов прямо в командной оболочке Python; 
- предоставляет редактор программного кода с подсветкой синтаксиса языка Python и поддержкой функции оформления отступов и отладчик, который может использоваться в режиме пошагового выполнения программного кода, облегчая поиск и устранение ошибок. 

Командная оболочка Python особенно удобна при опробовании простых алгоритмов, фрагментов программного кода и регулярных выражений и может использоваться как очень мощный и гибкий калькулятор. 

При желании для создания программ вы можете использовать простой текстовый редактор, а отладку выполнять посредством инструкций print(). 

В отличие от консольного варианта здесь можно наблюдать подсветку синтаксиса (в зависимости от значения синтаксической единицы она выделяется определенным цветом). Прокручивать список ранее введенных команд можно с помощью комбинаций Alt+N, Alt+P.

## Print - функция
Оператор print был заменён функцией print(), с именованными аргументами для замены большей части синтаксиса старого оператора print. 
### Примеры:
```
Python2: print "The answer is", 2*2
Python3: print("The answer is", 2*2)
Python2: print x,    # Запятая в конце подавляет перевод строки
Python3: print(x, end=" ")  # Добавляет пробел вместо перевода строки
Python2: print              # Печатает перевод строки
Python3: print()            # Нужно вызвать функцию!
Python2: print >>sys.stderr, "fatal error"
Python3: print("fatal error", file=sys.stderr)
Python2: print (x, y)       # Печатает repr((x, y))
Python3: print((x, y))      # Не путать с print(x, y)!
Также вы можете настроить разделитель между элементами, например:
>>> print("There are <", 2**32, "> possibilities!", sep="")
There are <4294967296> possibilities!
```
### Синтаксис
Конец строки является концом инструкции (точка с запятой не требуется).
Вложенные инструкции объединяются в блоки по величине отступов. Отступ может быть любым, главное, чтобы в пределах одного вложенного блока отступ был одинаков. Используйте 4 пробела.

Вложенные инструкции в Python записываются в соответствии с одним и тем же шаблоном, когда основная инструкция завершается двоеточием, вслед за которым располагается вложенный блок кода, обычно с отступом под строкой основной инструкции.

## Создание скриптов
### Кодировка исходного файла

- Кодировка Python должна быть UTF-8 (ASCII в Python 2).

- Файлы в ASCII (Python 2) или UTF-8 (Python 3) не должны иметь объявления кодировки.

В стандартной библиотеке, нестандартные кодировки должны использоваться только для целей тестирования, либо когда комментарий или строка документации требует упомянуть имя автора, содержащего не ASCII символы; в остальных случаях использование \x, \u, \U или \N - наиболее предпочтительный способ включить не ASCII символы в строковых литералах.

Начиная с версии python 3.0 в стандартной библиотеке действует следующее соглашение: все идентификаторы обязаны содержать только ASCII символы, и означать английские слова везде, где это возможно (во многих случаях используются сокращения или неанглийские технические термины). Кроме того, строки и комментарии тоже должны содержать лишь ASCII символы. Исключения составляют: (а) test case, тестирующий не-ASCII особенности программы, и (б) имена авторов. Авторы, чьи имена основаны не на латинском алфавите, должны транслитерировать свои имена в латиницу.

Проектам с открытым кодом для широкой аудитории также рекомендуется использовать это соглашение.
### Кодировки (PEP 263)
Код ядра python всегда должен использовать ASCII или Latin-1 кодировку (также известную как ISO-8859-1). Начиная с версии python 3.0, предпочтительной является кодировка UTF-8 (смотрите PEP 3120).
### Unicode Strings
```
>>>
>>> u'Hello World !'
u'Hello World !'
```
Python Unicode-Escape encoding.  escape sequence \u0020
```
>>>
>>> u'Hello\u0020World !'
u'Hello World !'
>>>
>>> ur'Hello\u0020World !'
u'Hello World !'
>>> ur'Hello\\u0020World !'
u'Hello\\\\u0020World !'
>>>
>>> u"abc"
u'abc'
>>> str(u"abc")
'abc'
>>> u"äöü"
u'\xe4\xf6\xfc'
>>> str(u"äöü")
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-2: ordinal not in range(128)
>>>
>>> u"äöü".encode('utf-8')
'\xc3\xa4\xc3\xb6\xc3\xbc'
unicode() function
>>>
>>> unicode('\xc3\xa4\xc3\xb6\xc3\xbc', 'utf-8')
u'\xe4\xf6\xfc'
>>> u'Слово' 
u'\u0421\u043b\u043e\u0432\u043e' 
>>> u'Слово'.encode('utf8') 
'\xd0\xa1\xd0\xbb\xd0\xbe\xd0\xb2\xd0\xbe' 
>>> u'\xd0\xa1\xd0\xbb\xd0\xbe\xd0\xb2\xd0\xbe' 
u'\xd0\xa1\xd0\xbb\xd0\xbe\xd0\xb2\xd0\xbe' 
>>> u'\u0421\u043b\u043e\u0432\u043e' 
u'\u0421\u043b\u043e\u0432\u043e' 
>>> print u'\u0421\u043b\u043e\u0432\u043e' 
Слово 
>>> print u'Слово' 
Слово 
>>> print 'Слово' 
Слово 
```
### Source Code Encoding
```
# -*- coding: encoding -*-
# -*- coding: cp-1252 -*-

```
# философия языка Python 
Этот документ описывает соглашение о том, как писать код для языка python, включая стандартную библиотеку, входящую в состав python. Пожалуйста, посмотрите также на сопутствующий PEP (python enhanced proposal — заявки на улучшение языка python), описывающий, какого стиля следует придерживаться при написании кода на C в реализации языка python.

Аббревиатура «PEP» расшифровывается как Python Enhancement Proposal (предложение по расширению Python). Если кто-то желает изменить или дополнить язык Python, и его стремление пользуется широкой поддержкой сообщества, он посылает PEP с подробным описанием своего предложения, чтобы его можно было рассмотреть в официальном порядке; в некоторых случаях, как это произошло с PEP 3131, предложение принимается и реализуется. Все предложения PEP можно найти на странице www.py-thon.org/dev/peps/.

Этот документ создан на основе рекомендаций Гуидо ван Россума с добавлениями от Барри. Если где-то возникал конфликт, мы выбирали стиль Гуидо. И, конечно, этот PEP может быть неполным (фактически, он, наверное, никогда не будет закончен).

Ключевая идея Гуидо такова: код читается намного больше раз, чем пишется. Собственно, рекомендации о стиле написания кода направлены на то, чтобы улучшить читабельность кода и сделать его согласованным между большим числом проектов. В идеале, весь код будет написан в едином стиле, и любой сможет легко его прочесть. Как говорится в PEP 20 «Читабельность имеет значение».

Это руководство о согласованности и единстве. Согласованность с этим руководством очень важна. Согласованность внутри одного проекта еще важнее. А согласованность внутри модуля или функции — самое важное. Но важно помнить, что иногда это руководство неприменимо, и понимать, когда можно отойти от рекомендаций. Когда вы сомневаетесь, просто посмотрите на другие примеры и решите, какой выглядит лучше.

### Две причины, чтобы нарушить правила:
Когда применение правила сделает код менее читабельным даже для того, кто привык читать код, который следует правилам. 
Чтобы писать в едином стиле с кодом, который уже есть в проекте и который нарушает правила (может быть, в силу исторических причин) — впрочем, это возможность подчистить чужой код. 

# Дзэн Питона
Если интерпретатору Питона дать команду import this (импортировать "сам объект"), то выведется так называемый "Дзен Питона", иллюстрирующий идеологию и особенности данного языка. Глубокое понимание этого дзена приходит тем, кто сможет освоить язык Python в полной мере и приобретет опыт практического программирования.
1. Beautiful is better than ugly. Красивое лучше уродливого. 
2. Explicit is better than implicit. Явное лучше неявного. 
3. Simple is better than complex. Простое лучше сложного. 
4. Complex is better than complicated. Сложное лучше усложнённого. 
5. Flat is better than nested. Плоское лучше вложенного. 
6. Sparse is better than dense. Разрежённое лучше плотного. 
7. Readability counts. Удобочитаемость важна. 
8. Special cases aren't special enough to break the rules. Частные случаи не настолько существенны, чтобы нарушать правила. 
9. Although practicality beats purity. Однако практичность важнее чистоты. 
10. Errors should never pass silently. Ошибки никогда не должны замалчиваться. 
11. Unless explicitly silenced. За исключением замалчивания, которое задано явно. 
12. In the face of ambiguity, refuse the temptation to guess. В случае неоднозначности сопротивляйтесь искушению угадать. 
13. There should be one — and preferably only one — obvious way to do it. Должен существовать один — и, желательно, только один — очевидный способ сделать это. 
14. Although that way may not be obvious at first unless you're Dutch. Хотя он может быть с первого взгляда не очевиден, если ты не голландец. 
15. Now is better than never. Сейчас лучше, чем никогда. 
16. Although never is often better than *right* now. Однако, никогда чаще лучше, чем прямо сейчас. 
17. If the implementation is hard to explain, it's a bad idea. Если реализацию сложно объяснить — это плохая идея. 
18. If the implementation is easy to explain, it may be a good idea. Если реализацию легко объяснить — это может быть хорошая идея. 
19. Namespaces are one honking great idea — let's do more of those! Пространства имён — прекрасная идея, давайте делать их больше! 

## Комментарии
Комментарии, которые противоречат коду, хуже, чем отсутствие комментариев. Всегда исправляйте комментарии, если меняете код!
Комментарии должны являться законченными предложениями. Если комментарий — фраза или предложение, первое слово должно быть написано с большой буквы, если только это не имя переменной, которая начинается с маленькой буквы (кстати, никогда не отступайте от этого правила для имен переменных).

Если комментарий короткий, можно опустить точку в конце предложения. Блок комментариев обычно состоит из одного или более абзацев, составленных из полноценных предложений, поэтому каждое предложение должно оканчиваться точкой.

Ставьте два пробела после точки в конце предложения.

Если вы пишете по-английски, не забывайте о Странке и Уайте (имеется в виду книга Strunk & White, “Elements of style”, которая является практически эталонным руководством по правильному написанию текстов на английском языке.)

Программисты, которые не говорят на английском языке, пожалуйста, пишите комментарии на английском, если только вы не уверены на 120 процентов, что ваш код никогда не будут читать люди, не знающие вашего родного языка.

### Блок комментариев
Блок комментариев обычно объясняет код (весь, или только некоторую часть), идущий после блока, и должен иметь тот же отступ, что и сам код. Каждая строчка такого блока должна начинаться с символа # и одного пробела после него (если только сам текст комментария не имеет отступа).

Абзацы внутри блока комментариев лучше отделять строкой, состоящей из одного символа #. 

### Комментарии в строке с кодом
Старайтесь реже использовать подобные комментарии.

Такой комментарий находится в той же строке, что и инструкция. «Встрочные» комментарии должны отделяться хотя бы двумя пробелами от инструкции. Они должны начинаться с символа # и одного пробела.

Комментарии в строке с кодом не нужны и только отвлекают от чтения, если они объясняют очевидное. Не пишите вот так:
```
x = x + 1                 # Увеличиваем X на один 
```
Впрочем, иногда такие комметарии полезны:
```
x = x + 1                  # Место для рамки окна 
```
# Строки документации
Соглашения о написании хорошей документации (docstrings) увековечены (да, забавно, но автор использует именно такое слово, — прим. перев.) в PEP 257.

Пишите документацию для всех модулей, функций, классов, методов, которые объявлены как public. Строки документации необязательны для не-public методов, но лучше написать, что делает метод. Комментарий нужно писать после строки с def.

PEP 257 объясняет, как правильно и хорошо документировать. Заметьте, очень важно, чтобы закрывающие """ стояли на отдельной строчке. А еще лучше, если перед ними будет ещё и пустая строка, например:
```
"""Return a foobang 
Optional plotz says to frobnicate the bizbaz first.

"""
``` 
Для однострочной документации можно оставить """ на той же строке.
# Основная инструкция:
## Вложенный блок инструкций
### Несколько специальных случаев
Иногда возможно записать несколько инструкций в одной строке, разделяя их точкой с запятой:
```
a = 1; b = 2; print(a, b)
```
Допустимо записывать одну инструкцию в нескольких строках. Достаточно ее заключить в пару круглых, квадратных или фигурных скобок:
```
if (a == 1 and b == 2 and
    c == 3 and d == 4):  # Не забываем про двоеточие
      print('spam' * 3)
```
Тело составной инструкции может располагаться в той же строке, что и тело основной, если тело составной инструкции не содержит составных инструкций. пример:
```
if x > y: print(x)
```
## Идентификаторы и ключевые слова 
Создавая элемент данных, мы можем либо присвоить его переменной, либо вставить в коллекцию. (когда в языке Python выполняется операция присваивания, в действительности происходит связывание ссылки на объект с объектом в памяти, который хранит данные.) 

Имена, которые даются ссылкам на объекты, называются идентификаторами, или просто именами. Допустимый идентификатор в языке Python - это последовательность символов произвольной длины, содержащей «начальный символ» и ноль или более «символов продолжения». Такой идентификатор  должен следовать определенным правилам и соглашениям. 

- Первое правило касается начального символа и символов продолжения. 

Начальным символом может быть любой символ, который в кодировке Юникод рассматривается как принадлежащий диапазону алфавитных символов ASCII («а», «Ь», ..., «z», «А», «В», ..., «Z»), символ подчеркивания («__»), а также символы большинства национальных (не английских) алфавитов. Каждый символ продолжения может быть любым символом из тех, что пригодны в качестве начального символа, а также любым непробельным символом, включая символы, которые в кодировке Юникод считаются цифрами, такие как («О», «1», ..., «9»), и символ Каталана «•». Идентификаторы чувствительны к регистру, поэтому TAXRATE, Tax rate, TaxRate, taxRate и tax rate - это пять разных идентификаторов. 

Точный перечень символов, допустимых для использования в качестве начального символа и символов продолжения, описывается в документации по языку Python (справочник «Language reference», раздел «Lexical analysis», подраздел «Identifiers and keywords»1) или в PEP 31312 (раздел «Supporting Non-ASCII Identifiers»). 

- Второе правило гласит
Не использовать в качестве своих идентификаторов любые предопределенные имена.

Как определить, относится ли тот или иной идентификатор к этим категориям? В языке Python имеется встроенная функция dir(), которая возвращает список атрибутов объекта. Если эта функция вызывается без аргументов, она возвращает список встроенных атрибутов языка Python.
```
dir()  ['__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__'] 
```
Атрибут builtins в действительности является модулем, в котором определены все встроенные атрибуты языка Python. Его можно использовать в качестве аргумента функции diг (): 
```
>» dir( builtins ) 
```
В списке присутствует более 130 имен. Имена, начинающиеся с символов верхнего регистра, являются именами встроенных исключений. Остальные имена представляют функции и типы данных. 

PyLint (www.logilab.org/project/name/pylint). Этот инструмент поможет вам также выявлять множество других фактических или потенциальных проблем в программах на языке Python. 

### соглашение касается использования символа подчеркивания (_). 
Не должны использоваться имена, начинающиеся и заканчивающиеся двумя символами подчеркивания. 

Символ подчеркивания сам по себе может использоваться в качестве идентификатора внутри интерактивной оболочки интерпретатора или в командной оболочке Python в переменной с именем _ сохраняется результат последнего вычисленного выражения. Во время выполнения обычной программы идентификатор _ отсутствует, если мы явно не определяем его в своем программном коде. Некоторые программисты любят использовать _ в качестве идентификатора переменной цикла в циклах for ... in, когда не требуется обращаться к элементам, по которым выполняются итерации. Например: 
```
for _ in (0, 1, 2, 3, 4, 5): 
print("Hello") 
```
Но имейте в виду, что те, кто пишет программы, которые затем интернационализируются, часто используют идентификатор _ в качестве имени функции перевода. 

Делается это, чтобы вместо необходимости писать всякий раз gettext.gettext("Translate me") можно было писать _("Translate me"). (Чтобы можно было выполнить такой вызов, мы сначала должны импортировать модуль gettext, чтобы получить доступ к функции gettext (), находящейся в этом модуле). 

```
pi = math.pi 
е = 0.0000001 
nueva_area = n * radio * radio 
if abs(nueva_area - vieja_area) < e: 
print("las areas han convergido") 
```
Самый простой способ проверить допустимость идентификатора состоит в том, чтобы попробовать присвоить ему некоторое значение в интерактивной оболочке интерпретатора Python или в командной оболочке Python среды IDLE.
```
>stretch-factor = 1 
SyntaxError: can't assign to operator (...) 
(SyntaxError: невозможно выполнить присваивание оператору (...)) 
> 2miles = 2 
SyntaxError: invalid syntax (...) 
Попытка использовать недопустимый идентификатор вызывает исключение SyntaxError. 
```
# Соглашения по именованию
Соглашения по именованию переменных в python немного туманны, поэтому их список никогда не будет полным — тем не менее, ниже мы приводим список рекомендаций, действующих на данный момент. Новые модули и пакеты должны быть написаны согласно этим стандартам, но если в какой-либо уже существующей библиотеке эти правила нарушаются, предпочтительнее писать в едином с ней стиле.

## Главный принцип

Имена, которые видны пользователю как часть общественного API должны следовать конвенциям, которые отражают использование, а не реализацию.

### Описание: Стили имен

Существует много разных стилей. Поможем вам распознать, какой стиль именования используется, независимо от того, для чего он используется.

### Обычно различают следующие стили:

- b (одиночная маленькая буква)
- B (одиночная заглавная буква)
- lowercase (слово в нижнем регистре)
- lower_case_with_underscores (слова из маленьких букв с подчеркиваниями)
- UPPERCASE (заглавные буквы)
- UPPERCASE_WITH_UNDERSCORES (слова из заглавных букв с подчеркиваниями)
- CapitalizedWords (слова с заглавными буквами, или CapWords, или CamelCase). Замечание: когда вы используете аббревиатуры в таком стиле, пишите все буквы аббревиатуры заглавными — HTTPServerError лучше, чем HttpServerError.
- mixedCase (отличается от CapitalizedWords тем, что первое слово начинается с маленькой буквы)
- Capitalized_Words_With_Underscores (слова с заглавными буквами и подчеркиваниями — уродливо!)

Ещё существует стиль, в котором имена, принадлежащие одной логической группе, имеют один короткий префикс. Этот стиль редко используется в python. Например, функция os.stat() возвращает кортеж, имена в котором традиционно имеют вид st_mode, st_size, st_mtime и так далее. (Так сделано, чтобы подчеркнуть соответствие этих полей структуре системных вызовов POSIX, что помогает знакомым с ней программистам).

В библиотеке X11 используется префикс Х для всех public-функций. В python этот стиль считается излишним, потому что перед полями и именами методов стоит имя объекта, а перед именами функций стоит имя модуля.

В дополнение к этому, используются следующие специальные формы записи имен с добавлением символа подчеркивания в начало или конец имени:

_single_leading_underscore: слабый индикатор того, что имя используется для внутренних нужд. Например, from M import * не будет импортировать объекты, чьи имена начинаются с символа подчеркивания.

single_trailing_underscore_: используется по соглашению для избежания конфликтов с ключевыми словами языка python, например:
```
Tkinter.Toplevel(master, class_='ClassName')
```
__double_leading_underscore: изменяет имя атрибута класса, то есть в классе FooBar поле __boo становится _FooBar__boo.

__double_leading_and_trailing_underscore__ (двойное подчеркивание в начале и в конце имени): магические методы или атрибуты, которые находятся в пространствах имен, управляемых пользователем. Например, __init__, __import__ или __file__. Не изобретайте такие имена, используйте их только так, как написано в документации.

### Предписания: соглашения по именованию

### Имена, которых следует избегать
Никогда не используйте символы l (маленькая латинская буква «эль»), O (заглавная латинская буква «о») или I (заглавная латинская буква «ай») как однобуквенные идентификаторы.

В некоторых шрифтах эти символы неотличимы от цифры один и нуля. Если очень нужно l, пишите вместо неё заглавную L.



## Внешний вид кода
### Отступы

Используйте 4 пробела на каждый уровень отступа.

Продолжительные строки должны выравнивать обернутые элементы либо вертикально, используя неявную линию в скобках (круглых, квадратных или фигурных), либо с использованием висячего отступа. При использовании висячего отступа следует применять следующие соображения: на первой линии не должно быть аргументов, а остальные строки должны четко восприниматься как продолжение линии.

```
# Выровнено по открывающему разделителю
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# Больше отступов включено для отличения его от остальных
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)
# Нет необходимости в большем количестве отступов.
foo = long_function_name(
  var_one, var_two,
  var_three, var_four)
```
Закрывающие круглые/квадратные/фигурные скобки в многострочных конструкциях могут находиться под первым непробельным символом последней строки списка, например:
```
my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
    )
```
либо быть под первым символом строки, начинающей многострочную конструкцию:
```
my_list = [
    1, 2, 3,
    4, 5, 6,
]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
)
```
## Табуляция или пробелы?

Пробелы - самый предпочтительный метод отступов.

Табуляция должна использоваться только для поддержки кода, написанного с отступами с помощью табуляции.

Python 3 запрещает смешивание табуляции и пробелов в отступах.

Python 2 пытается преобразовать табуляцию в пробелы.

Когда вы вызываете интерпретатор Python 2 в командной строке с параметром -t, он выдает предупреждения (warnings) при использовании смешанного стиля в отступах, а запустив интерпретатор с параметром -tt, вы получите в этих местах ошибки (errors). Эти параметры очень рекомендуются!
### Максимальная длина строки

Ограничьте длину строки максимум 79 символами.

Для более длинных блоков текста с меньшими структурными ограничениями (строки документации или комментарии), длину строки следует ограничить 72 символами.

Ограничение необходимой ширины окна редактора позволяет иметь несколько открытых файлов бок о бок, и хорошо работает при использовании инструментов анализа кода, которые предоставляют две версии в соседних столбцах.

Некоторые команды предпочитают большую длину строки. Для кода, поддерживающегося исключительно или преимущественно этой группой, в которой могут прийти к согласию по этому вопросу, нормально увеличение длины строки с 80 до 100 символов (фактически увеличивая максимальную длину до 99 символов), при условии, что комментарии и строки документации все еще будут 72 символа.

Стандартная библиотека Python консервативна и требует ограничения длины строки в 79 символов (а строк документации/комментариев в 72).

Предпочтительный способ переноса длинных строк является использование подразумеваемых продолжений строк Python внутри круглых, квадратных и фигурных скобок. Длинные строки могут быть разбиты на несколько строк, обернутые в скобки. Это предпочтительнее использования обратной косой черты для продолжения строки.

Обратная косая черта все еще может быть использована время от времени. Например, длинная конструкция with не может использовать неявные продолжения, так что обратная косая черта является приемлемой:
```
with open('/path/to/some/file/you/want/to/read') as file_1, \
        open('/path/to/some/file/being/written', 'w') as file_2:
    file_2.write(file_1.read())
```
## Пустые строки

Отделяйте функции верхнего уровня и определения классов двумя пустыми строками.

Определения методов внутри класса разделяются одной пустой строкой.

Дополнительные пустые строки возможно использовать для разделения различных групп похожих функций. Пустые строки могут быть опущены между несколькими связанными однострочниками (например, набор фиктивных реализаций).

Используйте пустые строки в функциях, чтобы указать логические разделы.

Python расценивает символ control+L как незначащий (whitespace), и вы можете использовать его, потому что многие редакторы обрабатывают его как разрыв страницы — таким образом логические части в файле будут на разных страницах. Однако, не все редакторы распознают control+L и могут на его месте отображать другой символ.

## Импорты

Каждый импорт, как правило, должен быть на отдельной строке.
```
import os
import sys
```
В то же время, можно писать так:
```
from subprocess import Popen, PIPE

```
Импорты всегда помещаются в начале файла, сразу после комментариев к модулю и строк документации, и перед объявлением констант.

Импорты должны быть сгруппированы в следующем порядке:

- импорты из стандартной библиотеки
- импорты сторонних библиотек
- импорты модулей текущего проекта

Вставляйте пустую строку между каждой группой импортов.

Указывайте спецификации __all__ после импортов.

Рекомендуется абсолютное импортирование, так как оно обычно более читаемо и ведет себя лучше если импортируемая система настроена неправильно (например, когда каталог внутри пакета заканчивается на sys.path):
```
import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example
```
Тем не менее, явный относительный импорт является приемлемой альтернативой абсолютному импорту, особенно при работе со сложными пакетами, где использование абсолютного импорта было бы излишне подробным:
```
from . import sibling
from .sibling import example
```
В стандартной библиотеке следует избегать сложной структуры пакетов и всегда использовать абсолютные импорты.

Неявные относительно импорты никогда не должны быть использованы, и были удалены в Python 3.


### Пробелы в выражениях и инструкциях
Избегайте использования пробелов в следующих ситуациях:

Непосредственно внутри круглых, квадратных или фигурных скобок.
```
spam(ham[1], {eggs: 2})

```
Непосредственно перед запятой, точкой с запятой или двоеточием:
```
if x == 4: print(x, y); x, y = y, x
```
Сразу перед открывающей скобкой, после которой начинается список аргументов при вызове функции:
```
spam(1)
```
Сразу перед открывающей скобкой, после которой следует индекс или срез:

```
dict['key'] = list[index]
```
Использование более одного пробела вокруг оператора присваивания (или любого другого) для того, чтобы выровнять его с другим:

```

x = 1
y = 2
long_variable = 3
```

### Другие рекомендации

Всегда окружайте эти бинарные операторы одним пробелом с каждой стороны: присваивания (=, +=, -= и другие), сравнения (==, <, >, !=, <>, <=, >=, in, not in, is, is not), логические (and, or, not).

Если используются операторы с разными приоритетами, попробуйте добавить пробелы вокруг операторов с самым низким приоритетом. Используйте свои собственные суждения, однако, никогда не используйте более одного пробела, и всегда используйте одинаковое количество пробелов по обе стороны бинарного оператора.
```
i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)
```
Не используйте пробелы вокруг знака =, если он используется для обозначения именованного аргумента или значения параметров по умолчанию.
```

def complex(real, imag=0.0):
    return magic(r=real, i=imag)
```

Не используйте составные инструкции (несколько команд в одной строке).

```

if foo == 'blah':
    do_blah_thing()
do_one()
do_two()
do_three()
```

Иногда можно писать тело циклов while, for или ветку if в той же строке, если команда короткая, но если команд несколько, никогда так не пишите. А также избегайте длинных строк!



## Советы по программированию на Python


### PyChecker

Используйте PyChecker для проверки своего кода

PyChecker — это инструмент для нахождения багов в исходниках Python-программ. Он находит проблемы, которые были бы выявлены компилятором менее динамичных языков, таких как С и С++. В силу динамической природы языка Python, некоторые предупреждения могут быть несправедливыми, однако ложные предупреждения не должны встречаться часто.


Отлавливает трудновыявляемые ошибки, такие как: ошибки типов, использование переменных перед их объявлением и т.д.


PyChecker не идеален. Чтобы получить все его преимущества нам нужно:
- Писать с оглядкой на него
- Подавить его предупреждения
- Исправлять ошибки
- Либо не обращать внимания на них внимания

Убедитесь, что Вы запустили PyChecker с вашим кодом. Для того чтобы узнать как запустить PyChecker, загляните на его домашнюю страницу. Чтобы подавить предупреждения, вам нужно создать переменную __pychecker__ в данном модуле и указать какие ошибки должны подавляться. Например:
```
__pychecker__ = 'no-callinit no-classattr'
```
Подавление предупреждений таким путем имеет преимущество следующего плана — мы можем с легкостью производить поиск по подавлениям и возвращаться к ним. Вы можете познакомиться со списком предупреждений PyChecker, если наберете:
```
pychecker -- help
```
Неиспользуемые аргументы могут быть опущены при помощи '_', как наименования неиспользуемого аргумента, либо префикса аргумента «unused_». В ситуациях когда изменение имени аргумента невозможно, Вы можете упомянуть их в начале функции. Например:
```
def foo(a, unused_b, unused_c, d=None, e=None):
    _ = d, e
    return a
```


# Глобальные переменные

Избегайте использования глобальных переменных

Переменные, которые определены на уровне модуля.

Иногда полезны.

Можно нечаянно изменить поведение модуля при импорте, т.к. присваивание переменных уровня модуля уже завершено когда модуль импортируется.

Избегайте использования глобальных переменных в пользу переменных класса. 

### Несколько исключений ниже:
### Стандартные настройки скриптов.
Константы уровня модуля. Например, PI = 3.14159. Константы должны быть именованы с использованием только заглавных букв и символа подчеркивания. 

Иногда полезно использовать глобальные переменные, чтобы кэшировать значения, необходимые для функции или возвращаемые функцией.


# Модуль keyword

keyword.kwlist - список всех доступных ключевых слов (почему не кортеж, непонятно).
keyword.iskeyword(строка) - является ли строка ключевым словом.

## Ключевые слова

- False - ложь.
- True - правда.
- None - "пустой" объект.
- and - логическое И.
- with / as - менеджер контекста.
- assert условие - возбуждает исключение, если условие ложно.
- break - выход из цикла.
- class - пользовательский тип, состоящий из методов и атрибутов.
- continue - переход на следующую итерацию цикла.
- def - определение функции.
- del - удаление объекта.
- elif - в противном случае, если.
- else - см. for/else или if/else.
- except - перехватить исключение.
- finally - вкупе с инструкцией try, выполняет инструкции независимо от того, было ли исключение или нет.
- for - цикл for.
- from - импорт нескольких функций из модуля.
- global - позволяет сделать значение переменной, присвоенное ей внутри функции, доступным и за пределами этой функции.
- if - если.
- import - импорт модуля.
- in - проверка на вхождение.
- is - ссылаются ли 2 объекта на одно и то же место в памяти.
- lambda - определение анонимной функции.
- nonlocal - позволяет сделать значение переменной, присвоенное ей внутри функции, доступным в объемлющей инструкции.
- not - логическое НЕ.
- or - логическое ИЛИ.
- pass - ничего не делающая конструкция.
- raise - возбудить исключение.
- return - вернуть результат.
- try - выполнить инструкции, перехватывая исключения.
- while - цикл while.
- yield - определение функции-генератора.

# Типы данных 
Типы данных считаются встроенными за исключением тех, что определены в стандартной библиотеке. Единственное отличие встроенных типов данных от библиотечных состоит в том, что, прежде чем воспользоваться последними, нам необходимо импортировать соответствующие модули и мы должны квалифицировать имена типов именами модулей, в которых они определяются. 
```
>>> type(message)
<type 'str'>
>>> type(n)
<type 'int'>
>>> type(pi)
<type 'float'>
Statements
print 1
x = 2 
print x 
```

Python Program
1.py
#!/usr/bin/python 
print 'Hello there' 

2.py
#!/usr/bin/python 
print '2 * 2 = '
print c

3.py
#!/usr/bin/python 
a = 2 
b = 2 
c = a*b 
print '2 * 2 = ',  c
4 If you are not sure what type a value has, the interpreter can tell you.
>>> type('Hello, World!') 
<type 'str'> 
>>> type(17) 
<type 'int'>
floating-point.
>>> type(3.2) 
<type 'float'>
What about values like '17' and '3.2'? They look like numbers, but they are in quotation marks like strings.
>>> type('17') 
<type 'str'> 
>>> type('3.2') 
<type 'str'> 
They're strings.
When you type a large integer, you might be tempted to use commas between groups of three digits, as in 1,000,000. This is not a legal integer in Python, but it is a legal expression:
>>> print 1,000,000
1 0 0

4.py
a = 2 
b = 2 
c = a*b 
print '2 * 2 = ',  c 
print type(c) 

## Целочисленные типы 
В языке Python имеется два целочисленных типа, int и bool. И целые числа, и логические значения являются неизменяемыми объектами, но благодаря присутствию в языке Python комбинированных операторов присваивания эта особенность практически незаметна. В логических выражениях число 0 и значение False представляют False, а любое другое целое число и значение True представляют True. В числовых выражениях значение True представляет 1, a False - 0. Это означает, что можно записывать весьма странные выражения, например, выражение i+=True увеличит значение i на единицу. Естественно, более правильным будет записывать подобные выражения как i += 1. 
### Целые числа 
Размер целого числа ограничивается только объемом памяти компьютера. Литералы целых чисел по умолчанию записываются в десятичной системе счисления, но при желании можно использовать другие системы счисления: 
```
> 14600926 # десятичное число 
14600926 
>0b10111101100101011011110 # двоичное число 
14600926 
>0о67545336 и восьмеричное число 
14600926 
>0xDECADE # шестнадцатеричное число 
14600926 
```
Некоторые из функциональных возможностей представлены встроенными функциями, такими как abs()  int. 

Для всех двухместных арифметических операторов (+, -, /, //, % и **) имеются соответствующие комбинированные операторы присваивания (+=, -=, /=, //=, %= и **=), где выражение х ор= у является логическим эквивалентом выражения х = х ор у, когда в обычной ситуации обращение к значению х не имеет побочных эффектов. 

Некоторые объекты (например, типа decimal. Decimal) могут создаваться только посредством использования их типов, так как они не имеют литерального представления. 

Первый вариант - вызов типа данных без аргументов. В этом случае объект приобретает значение по умолчанию, например, выражение х = int() создаст целое число 0. Любые встроенные типы могут вызываться без аргументов. Второй вариант - тип вызывается с единственным аргументом. Если указан аргумент соответствующего типа, будет создана поверхностная копия оригинального объекта.  Если задан аргумент другого типа, будет предпринята попытка выполнить преобразование. Если аргумент имеет тип, для которого поддерживается преобразование в требуемый тип, и преобразование терпит неудачу, возбуждается исключение ValueError, в противном случае возвращается результат преобразования - объект 


## х + у  х — у  х * у  х / у X // У  х % у  х ** у  -X  +х  

 х / у Делит х на у - результатом всегда является значение типа float (или complex, если х или у является комплексным числом) 

X // У  Делит х на у, при этом усекает дробную часть, поэтому результатом всегда является значение типа int, смотрите также функцию round() 

5.py
```
#!/usr/bin/python 
a = 21 
b = 2 
c = a/b 
print c 
print type(c) 
c = a//b 
print c 
print type(c) 
d = 3.5 
c = a/d 
print c 
print type(c) 
c = a%b 
print c 
print type(c)
```
abs(x) Возвращает абсолютное значение х 

divmod(x, у) Возвращает частное и остаток деления х на у в виде кортежа двух значений типа int 32 130 

pow(x, у) Возводит х в степень у; то же самое, что и оператор ** 

pow(x, у, z) Более быстрая альтернатива выражению (х ** у) % z 

round(x, n)  Возвращает значение типа int, соответствующее значению х типа float, округленному до ближайшего целого числа (или значение типа float, округленное до n-го знака после запятой, если задан аргумент п) требуемого типа. Если тип аргумента не поддерживает преобразование в требуемый тип, возбуждается исключение TypeError. 

7
```
#!/usr/bin/python 
a = 21 
b = 2 
c = b - a 
print 'abs = ', abs(c) 
c = divmod(a,b) 
print 'divmod = ', c 
c = pow(a,b) 
print 'pow = ', c 
c = round(2.7777,2) 
print 'round(2.7777,2) = ', c
```
Все битовые операторы (|, ~, &, >> и <<) имеют соответствующие комбинированные операторы присваивания (| =, ~=, &=, «= и »=), где выражение i op= j является логическим эквивалентом выражения i = i op j в случае, когда обращение к значению i не имеет побочных эффектов. 

Если имеется необходимость хранить множество флагов, способных иметь всего два состояния, можно использовать единственное целое число и проверять значения отдельных его битов с помощью битовых операторов. То же самое можно делать менее компактным, но более удобным способом, воспользовавшись логическим типом. 

bin(i)      Возвращает двоичное представление целого числа i в виде строки, например, bin(1980) == 'ОЫПЮПИОО' 

hex(i)      Возвращает шестнадцатеричное представление целого числа i в виде строки, например, hex( 1980) == '0x7bc' 

int(x)      Преобразует объект х в целое число; в случае ошибки во время преобразования возбуждает исключение ValueError, а если тип объекта х не поддерживает преобразование в целое число, возбуждает исключение ТуреЕггог. Если х является числом с плавающей точкой, оно преобразуется в целое число путем усечения дробной части. 

int(s, base)    Преобразует строку s в целое число, в случае ошибки возбуждает исключение ValueError. Если задан необязательный аргумент base, он должен быть целым числом в диапазоне от 2 до 36 включительно. 

oct(i)      Возвращает восьмеричное представление целого числа i в виде строки, например, oct( 1980) == '0о3674" 
```
i = 21 
b = 2 
print 'bin(i) = ', bin(1) 
print 'hex(i) = ', hex(i) 
print 'oct(i) = ', oct(i) 
print 'int(55.88) = ', int(55.88)
```
## Логические значения 
Существует два встроенных логических объекта: True и False. Как и все остальные типы данных в языке Python, тип данных bool может вызываться как функция - при вызове без аргументов возвращается значение False, при вызове с аргументом типа bool возвращается копия аргумента, а при вызове с любым другим аргументом предпринимается попытка преобразовать указанный объект в тип bool. Все встроенные типы данных и типы данных из стандартной библиотеки могут быть преобразованы в тип bool. Ниже приводится пара присваиваний логических значений и пара логических выражений: 
```
> t = True 
> f = False 
> t and f 
False 
> t and True 
True 
```
в языке Python имеется три логических оператора: and, or и not. Выражения с участием операторов and и or вычисляются в соответствии с логикой сокращенных вычислений (short-circuit logic), и возвращается операнд, определяющий значение всего выражения, тогда как результатом оператора not всегда является либо True, либо False. 

## Вычисления True/False


Python вычисляет определенные значения в False, когда мы находимся в контексте булевых значений. Самый просто способ запомнить это — знать, что все “пустые” значения, такие как False, 0, None, [], {} — вычисляются в False в булевом контексте.

Такие условные конструкции, использующие булевы значения Python, удобочитаемы и меньше подвержены ошибкам. В большинстве случаев они работают быстрее.

Могут выглядеть странно для разработчиков на С/С++.

Используйте False явно, если это возможно. Например, if foo: лучше, чем if foo != []:. Вы должны помнить несколько исключений:

Никогда не используйте == или != для сравнения объектов синглтона, таких как None. Используйте is или is not.

Остерегайтесь написания if x:, когда Вы подразумеваете if x is not None:, например, когда происходит тестирование переменной или аргумента, которые по умолчанию равны None, но их значение было изменено на другое. Другое значение может вычисляться в False при булевой проверке.

Никогда не сравнивайте булеву переменную с False, используя ==. 
Используйте if not x вместо этого. Если вам нужно отличить False от None, тогда используйте цепочечное выражение, такое как if not x and x is not None.

Когда Вы работаете с целыми числами, явное сравнение с False несет больший риска, чем выгоды (случайная обработка None как 0). Вы можете сравнивать значение, которое является целым числом (и не является результатом выполнения функции len()) c нулем.
```

if not users:
    print "no"

if foo == 0:
    self.handle_zero()

if i % 10 == 0:
  self.handle_multiple_of_ten()

```

Заметьте, что “0” (т.е. 0 как строка) вычисляется в True.


### Тип чисел с плавающей точкой 
Язык Python предоставляет три типа значений с плавающей точкой: 
встроенные типы float и complex и тип decimal. Decimal в стандартной библиотеке. Все три типа данных относятся к категории неизменяемых. Тип float представляет числа с плавающей точкой двойной точности, диапазон значений которых зависит от компилятора языка С (или С# или Java), применявшегося для компиляции интерпретатора Python. Числа этого типа имеют ограниченную точность и не могут надежно сравниваться на равенство значений. Числа типа float записываются с десятичной точкой или в экспоненциальной форме записи, например, 0.0, 4., 5.7, -2.5, -2е9, 8.9е-4. 

В машинном представлении числа с плавающей точкой хранятся как двоичные числа. Это означает, что одни дробные значения могут быть представлены точно (такие как 0.5), а другие - только приблизительно (такие как 0.1 и 0.2). Кроме того, для представления используется фиксированное число битов, поэтому существует ограничение на количество цифр в представлении таких чисел. Ниже приводится поясняющий пример, полученный в IDLE: 
```
> 0.0, 5.4, -2.5, 8.9е-4 
(0.0, 5.4000000000000004, -2.5, 0.00088999999999999995) 
```
Проблема потери точности - это не проблема, свойственная только языку Python; все языки программирования обнаруживают проблему с точным представлением чисел с плавающей точкой. 

Если вам действительно необходимо обеспечить высокую точность, можно использовать числа типа decimal.Decimal. Эти числа обеспечивают уровень точности, который вы укажете (по умолчанию 28 знаков после запятой), и могут точно представлять периодические числа, такие как 0.11, но скорость работы с такими числами существенно ниже, чем с обычными числами типа float. Вследствие высокой точности числа типа decimal.Decimal прекрасно подходят для производства финансовых вычислений. 
```
decimal.Decimal(2.99)
Decimal('2.9900000000000002131628207280300557613372802734375')
```
Смешанная арифметика поддерживается таким образом, что результатом выражения с участием чисел типов int и float является число типа float, а с участием типов float и complex результатом является число типа complex. Поскольку числа типа decimal.Decimal имеют фиксированную точность, они могут участвовать в выражениях только с другими числами decimal. Decimal и с числами типа int; результатом таких выражений является число decimal.Decimal. В случае попытки выполнить операцию над несовместимыми типами возбуждается исключение ТуреЕггог. 
### Числа с плавающей точкой 
Тип данных float может вызываться как функция - без аргументов возвращается число 0.0, с аргументом типа float возвращается копия аргумента, а с аргументом любого другого типа предпринимается попытка выполнить преобразование указанного объекта в тип float. При преобразовании строки аргумент может содержать либо простую форму записи числа с десятичной точкой, либо экспоненциальное представление числа. При выполнении операций с числами типа float может возникнуть ситуация, когда в результате получается значение NaN (not a number - не число) или «бесконечность». К сожалению, поведение интерпретатора в таких ситуациях может отличаться в разных реализациях и зависит от математической библиотеки системы. 
пример простой функции, выполняющей сравнение чисел типа float на равенство в пределах машинной точности: 
```
def equal_float(a, b): 
    return abs(a - b) <= sys.float_info.epsilon 
```
Чтобы воспользоваться этой функцией, необходимо импортировать модуль sys. Объект sys. float_info имеет множество атрибутов. Так, sys. float_info. epsilon хранит минимально возможную разницу между двумя числами с плавающей точкой.  

(Epsilon - это традиционное название чисел такого рода.) Тип float в языке Python обеспечивает надежную точность до 17 значащих цифр. 

Если ввести sys.float_info в среде IDLE, будут выведены все атрибуты этого объекта, куда входят минимальное и максимальное значения чисел с плавающей точкой, которые могут быть представлены машиной. А если ввести команду help(sys.float_info), будет выведена некоторая информация об объекте sys.float_info. 

Числа с плавающей точкой можно преобразовать в целые числа с помощью функции int(), которая возвращает целую часть и отбрасывает дробную часть, или с помощью функции round(), которая учитывает величину дробной части, или с помощью функций math.floor() и math.ceil(), которые округляют вверх или вниз до ближайшего целого. Метод float.is_integer() возвращает значение True, если дробная часть числа равна 0. Представление дробной части числа можно получить с помощью метода float.as_integer_ratio(). Например, пусть х = 2.75, тогда метод х.as_integer_ratio() вернет (11, 4). Преобразование целых чисел в тип float можно выполнить с помощью функции float(). 

Числа с плавающей точкой также могут быть представлены в виде строк в шестнадцатеричном формате с помощью метода float.hex(). 

Обратное преобразование может быть выполнено с помощью метода float.fromhex() Например: 
```
s = 14.25.hex() # str s == '0x1.c800000000000p+3' 
f = float.fromhex(s) # float f == 14.25 
t = f.hex() # str t == '0x1.c800000000000p+3'
```
Экспонента отмечается с помощью символа р (power - «степень»), а не е, так как символ е представляет допустимую шестнадцатеричную цифру. 
import math 
```
> math.pi * (5 ** 2) 
78.539816339744831 
>math.hypot(5, 12) 
13.0 
>math.modf(13.732) 
(0.73199999999999932, 13.0) 
```
Функция math.hypot() вычисляет расстояние от начала координат до точки (х, у) и дает тот же результат, что и выражение math.sqrt((x ** 2) + (У ** 2)). 
### Функции и константы модуля math 

- math.acos(x) Возвращает арккосинус х в радианах 
- math.acosh(x) Возвращает гиперболический арккосинус х в радианах 
- math.asin(x) Возвращает арксинус х в радианах 
- math.asinh(x) Возвращает гиперболический арксинус х в радианах 
- math.atan(x) Возвращает арктангенс х в радианах 
- math.atan2(y, x) Возвращает арктангенс у/х в радианах 
- math.atanh(x) Возвращает гиперболический арктангенс х в радианах 
- math.ceil(x) Возвращает ГдЛ, то есть наименьшее целое число типа int, большее и равное х, например, math, ceil(5.4) == 6 
- math.copysign(x.y) Возвращает х со знаком числа у 
- math.cos(x) Возвращает косинус х в радианах 
- math.cosh(x) Возвращает гиперболический косинус х в радианах 
- math.degrees(r) Преобразует число г, типа float, из радианов в градусы 
- math.e Константа е, примерно равная значению 2.7182818284590451 
- math.exp(x) Возвращает ех, то есть math. е * * х 
- math.fabs(x) Возвращает абсолютное значение х в виде числа типа float 
- math.factorial(x) 
- math.floor(x) Возвращает наименьшее целое число типа int, меньшее и равное х, например, math, floor(5.4) == 5 
- math.fmod(x, y) Выполняет деление по модулю (возвращает остаток) числа х на число у; дает более точный результат, чем оператор %, применительно к числам типа float 
- math.frexp(x) Возвращает кортеж из двух элементов /^ \ с мантиссой (в виде числа типа float) и экспонентой (в виде числа типа int) ч _ J 
- math.fsum(i) Возвращает сумму значений в итерируемом объекте i в виде числа типа float 
- math.hypot(x, y) Возвращает sqrt(x*x + y*y); Функция hypot вычисляет длину гипотенузы прямоугольного треугольника с заданной длиной двух сторон x и y. 
- math.isinf(x) Возвращает True, если значение х типа float является бесконечностью (±inf (±оо)) 
- math.isnan(x) Возвращает True, если значение х типа float не является числом 
- math.ldexp(m, e) Возвращает тх2е - операция, обратная math, f гехр() 
math.log(x, b) Возвращает log^x, аргумент b является необязательным и по умолчанию имеет значение math. e 
- math.Iog10(x) Возвращает /og10# 
- math.loglp(x) Возвращает loge(l+x); дает точные значения, даже когда значение х близко к 0 
- math.modf(x) Возвращает дробную и целую часть числа х в виде двух значений типа float 
- math.pi Константа я, примерно равна 3.1415926535897931 
- math.pow(x, у) Возвращает ху в виде числа типа float 
- math.radians(d) Преобразует число d, типа float, из градусов в радианы 
- math.sin(x) Возвращает синус х в радианах 
- math.sinh(x) Возвращает гиперболический синус х в радианах 
- math.sqrt(x) Возвращает Jx 
- math.sum(i) Возвращает сумму значений в итерируемом объекте i в виде числа типа float8 
- math.tan(x) Возвращает тангенс х в радианах 
- math.tanh(x) Возвращает гиперболический тангенс х в радианах 
- math.trunc(x) Возвращает целую часть числа х в виде значения типа int; то же самое, что и int(x) а Функции math.sum в модуле math нет; предполагаю, что эта функция в  Python 3.0 вытеснена функцией math.fsum. 
## Комплексные числа 
Тип данных complex относится к категории неизменяемых и хранит пару значений типа float, одно из которых представляет действительную часть комплексного числа, а другое - мнимую. Литералы комплексных чисел записываются как действительная и мнимая части, объединенные знаком + или -, а за мнимой частью числа следует символ j.1 Вот примеры нескольких комплексных чисел: 3. 5+2j, 0. 5j, 4+0j, -1-3.7j. Обратите внимание, что если действительная часть числа равна 0, ее можно вообще опустить. 
Отдельные части комплексного числа доступны в виде атрибутов real и imag. Например: 
```
z = -89.5+2.125J 
z.real, z.imag 
(-89.5, 2.125) 
```
За исключением //, %, divmod() и версии pow() с тремя аргументами все остальные арифметические операторы и функции могут использоваться для работы с комплексными числами, так же как и соответствующие комбинированные операторы присваивания. Кроме того, значения типа complex имеют метод conjugate(), который изменяет знак мнимой части. Например: 
```
z.conjugate() 
(-89.5-2.125j) 
3-4j.conjugate() 
(3+4j) 
```
## Числа типа Decimal 
Во многих приложениях недостаток точности, свойственный числам типа float, не имеет существенного значения, и эта неточность окупается скоростью вычислений. Но в некоторых случаях предпочтение отдается точности, даже в обмен на снижение скорости работы. 

Модуль decimal реализует неизменяемый числовой тип Decimal, который представляет числа с задаваемой точностью. Вычисления с участием таких чисел производятся значительно медленнее, чем в случае использования значений типа float, но насколько это важно, будет зависеть от приложения. Чтобы создать объект типа Decimal, необходимо импортировать модуль decimal. Например: 
```
>» import decimal 
>» а = decimal.Decimal(9876) 
>» b = decimal.Decimal(,,54321.012345678987654321") 
>» a + b 
DecimaK'64197.012345678987654321") 
```
Числа типа Decimal создаются с помощью функции decimal.Decimal(). 
Эта функция может принимать целочисленный или строковый аргумент, но не значение типа float, потому что числа типа float не всегда имеют точное представление, а числа типа Decimal всегда представляются точно. Если в качестве аргумента используется строка, она может содержать изображение числа как в обычной десятичной форме записи, так и в экспоненциальной. Кроме того, возможность явно определить точность представления числа decimal.Decimal означает, что они надежно могут проверяться на равенство. 

Если слева от оператора ** находится объект типа decimal. Decimal, то справа от оператора должно быть целое число. Точно так же, если первый аргумент функции pow() имеет тип decimal. Decimal, то второй и необязательный  третий аргументы должны быть целыми числами. 

Модули math и cmath не могут использоваться для работы с числами типа decimal. Decimal, однако некоторые функции, присутствующие в модуле math, реализованы как методы типа decimal.Decimal. Например, чтобы вычислить ех, где х имеет тип float, вызывается функция math.exp(x), а когда х имеет тип decimal. Decimal, следует использовать метод х. ехр(). 

Кроме того, тип данных decimal. Decimal предоставляет метод 1п(), который вычисляет натуральные (по основанию е) логарифмы (точно так же, как функция math.logO с одним аргументом), 1од10() и sqrt(), а также множество других методов, адаптированных для обработки значений типа decimal. 
```
>» 23 / 1.05 
21.904761904761905 
>» print(23 / 1.05) 
21.9047619048 
>» print(decimal.Decimal(23) / decimal.Decimal("1.05"')) 
21.90476190476190476190476190 
>» decimal.Decimal(23) / decimal.Decimal("1.05") 
DecimaK'21.90476190476190476190476190') 
```

## Синтаксис инструкции if
Общая форма записи условной инструкции if выглядит следующим образом:
```
if test1:
    state1
elif test2:
    state2
else:
    state3
```
Простой пример (напечатает 'true', так как 1 - истина):
```
if 1:
    print('true')
else:
    print('false')

true
```
пример (результат будет зависеть от того, что ввёл пользователь): a = raw_input()
```
a = int(input())
if a < -5:
    print('Low')
elif -5 <= a <= 5:
    print('Mid')
else:
    print('High')
```
Конструкция с несколькими elif может также служить отличной заменой конструкции switch - case в других языках программирования.
### Проверка истинности в Python
- Любое число, не равное 0, или непустой объект - истина.
- Числа, равные 0, пустые объекты и значение None - ложь
- Операции сравнения применяются к структурам данных рекурсивно
- Операции сравнения возвращают True или False
- Логические операторы and и or возвращают истинный или ложный объект-операнд
### Логические операторы:

- X and Y
Истина, если оба значения X и Y истинны.
- X or Y
Истина, если хотя бы одно из значений X или Y истинно.
- not X
Истина, если X ложно.

#### Трехместное выражение if/else
Следующая инструкция:
```
if X:
    A = Y
else:
    A = Z
```
довольно короткая, но, тем не менее, занимает целых 4 строки. Специально для таких случаев и было придумано выражение if/else:
```
A = Y if X else Z
```
В данной инструкции интерпретатор выполнит выражение Y, если X истинно, в противном случае выполнится выражение Z.
```
>>> A = 't' if 'spam' else 'f'
>>> A
't'
# Program make a simple calculator that can add, subtract, multiply and divide using functions

# define functions
def add(x, y):
   """This function adds two numbers"""

   return x + y

def subtract(x, y):
   """This function subtracts two numbers"""

   return x - y

def multiply(x, y):
   """This function multiplies two numbers"""

   return x * y

def divide(x, y):
   """This function divides two numbers"""

   return x / y

# take input from the user
print("Select operation.")
print("1.Add")
print("2.Subtract")
print("3.Multiply")
print("4.Divide")

choice = input("Enter choice(1/2/3/4):")

num1 = int(input("Enter first number: "))
num2 = int(input("Enter second number: "))

if choice == '1':
   print(num1,"+",num2,"=", add(num1,num2))

elif choice == '2':
   print(num1,"-",num2,"=", subtract(num1,num2))

elif choice == '3':
   print(num1,"*",num2,"=", multiply(num1,num2))

elif choice == '4':
   print(num1,"/",num2,"=", divide(num1,num2))
else:
   print("Invalid input")
```
## Цикл while
While - один из самых универсальных циклов в Python, поэтому довольно медленный. Выполняет тело цикла до тех пор, пока условие цикла истинно.
```
i = 5
while i < 15:
    print(i)
    i = i + 2
```

### Цикл for
Цикл for уже чуточку сложнее, чуть менее универсальный, но выполняется гораздо быстрее цикла while. Этот цикл проходится по любому итерируемому объекту (строке, списку,...), и во время каждого прохода выполняет тело цикла.
```
for i in 'hello world':
    print(i * 2, end='')


```
### Оператор continue
Оператор continue начинает следующий проход цикла, минуя оставшееся тело цикла (for или while)
```
>>> for i in 'hello world':
    if i == 'o':
        continue
    print(i * 2, end='')

```

### Оператор break
Оператор break досрочно прерывает цикл.
```
for i in 'hello world':
    if i == 'o':
        break
    print(i * 2, end='')

```

### Волшебное слово else
Слово else, примененное в цикле for или while, проверяет, был ли произведен выход из цикла инструкцией break, или же "естественным" образом. Блок инструкций внутри else выполнится только в том случае, если выход из цикла произошел без помощи break.
```
for i in 'hello world':
    if i == 'a':
        break
else:
    print('Буквы a в строке нет')


```
