## Запись и чтение файлов
Функция open() возвращает объект файла и в большинстве случаев используется с двумя аргументами: open(имя_файла, режим).
```
f = open('/tmp/workfile', 'w')
print f
```

Первый аргумент — строка, содержащая имя файла. Второй аргумент — другая строка, содержащая несколько символов, описывающих каким образом файл будет использоваться. Значение аргумента режим может быть символом 'r', если файл будет открыт только для чтения, 'w' — открыт только для записи (существующий файл с таким же именем будет стёрт), и 'a' — файл открыт для добавления: любые данные, записанные в файл автоматически добавляются в конец. 'r+' открывает файл и для чтения и для записи. Аргумент режим необязателен: если он опущен — предполагается, что он равен 'r'.

При использовании ОС Windows, символ 'b', добавленный к аргументу режим, открывает файл в двоичном режиме (binary mode), так что существуют такие режимы как 'rb', 'wb' и 'r+b'. Для платформы Windows есть разница между текстовыми и двоичными файлами — символы конца строки в текстовых файлах сильно модифицируются при записи или чтении данных. Изменение данных файла «за кулисами» нормально работает для текстовых файлов в ASCII, но повреждает двоичные данные, такие как в файлах JPEG или EXE. Будьте осторожны и используйте двоичный режим при чтении и записи таких файлов. На системах Unix, добавление символа 'b' к режиму не причиняет никаких неудобств, так что вы можете использовать его для всех двоичных файлов, независимо от платформы.

##  Открытие и закрытие файла в Python.
Перед тем как прочесть и записать что-либо в файл, его следует открыть. Чтобы открыть файл в Python используется встроенная функция open(). При вызове, эта функция создает объект типа файл, с которым в дальнейшем можно работать.

### Синтаксис функции open() в Python.
```
my_file = open(имя_файла [, режим_доступа][, буферизация])
```
При этом:
- имя_файла: строка, содержащая имя файла с расширением. Например, "my_file.txt".
- режим_доступа: строка, которой мы указываем для чего открывается файл: для чтения, записи, добавления информации, и т.д. Например, "w". По умолчанию файл открывается для чтения - "r".
- буферизация: Челое число. Если значение аргумента указано 0 - файл открывается без буферизации, 1 с построчной буферизацией, больше одного процесс буферизации выполняется с указанным размером буфера. Отрицательное число - разер буфера будет равен системному.

### Список режимов доступа к файлу в Python.
- r   Открывает файл только для чтения. Указатель стоит в начале файла.
rb  Открывает файл для чтения в двоичном формате. Указатель стоит в начале файла.
- r+  Открывает файл для чтения и записи. Указатель стоит в начале файла.
- rb+ Открывает файл для чтения и записи в двоичном формате. Указатель стоит в начале файла.
- w   Открывает файл только для записи. Указатель стоит в начале файла. Создает файл с именем имя_файла, если такового не существует.
- wb  Открывает файл для записи в двоичном формате. Указатель стоит в начале файла. Создает файл с именем имя_файла, если такового не существует.
- w+  Открывает файл для чтения и записи. Указатель стоит в начале файла. Создает файл с именем имя_файла, если такового не существует.
- wb+ Открывает файл для чтения и записи в двоичном формате. Указатель стоит в начале файла. Создает файл с именем имя_файла, если такового не существует.
- a   Открывает файл для добавления информации в файл. Указатель стоит в конце файла. Создает файл с именем имя_файла, если такового не существует.
- ab  Открывает файл для добавления в двоичном формате. Указатель стоит в конце файла. Создает файл с именем имя_файла, если такового не существует.
- a+  Открывает файл для добавления и чтения. Указатель стоит в конце файла. Создает файл с именем имя_файла, если такового не существует.
- ab+ Открывает файл для добавления и чтения в двоичном формате. Указатель стоит в конце файла. Создает файл с именем имя_файла, если такового не существует.

### Атрибуты файлового объекта в Python.
Как только файл был открыт и у вас появился файловый объект, вы можете получить следующую информацию о нем:
- file.closed Возвращает True если файл был закрыт.
- file.mode   Возвращает режим доступа, с которым был открыт файл.
- file.name   Возвращает имя файла.
- file.softspace  Возвращает False если при выводе содержимого файла следует отдельно добавлять пробел.

Например:
````
my_file = open("some.txt", "w")
print("Имя файла: ", my_file.name)
print("Файл закрыт: ", my_file.closed)
print("В каком режиме файл открыт: ", my_file.mode)
print("Пробелы: ", my_file.softspace)
```
## Закрытие файла в Python. Метод close().

Метод файлового объекта close() автоматически закрывает файл, при этом теряется любая несохраненная информация. Работать с файлом (читать, записывать) после этого нельзя.
Python автоматически закрывает файл если файловый объект к которому он привязан присваивается другому файлу. Однако, хорошей практикой будет вручную закрывать файл командой close().
```
my_file = open("some.txt")
print("Имя файла: ", my_file.name)
print("Файл закрыт: ", my_file.closed)
my_file.close()
print("А теперь закрыт: ", my_file.closed)

```

# Методы объектов File

Чтобы прочитать содержимое файла вызовите f.read(размер) — функция читает некоторое количество данных и возвращает их в виде строки. размер — необязательный числовой аргумент. Если размер опущен или отрицателен, будет прочитано и возвращено всё содержимое файла; если файл по величине в два раза больше оперативной памяти вашего компьютера, то решение этой проблемы остаётся на вашей совести. В обратном случае, будет прочитано и возвращено максимум размер байт. Если был достигнут конец файла, f.read() вернёт пустую строку ("").


## Чтение из файла в Python. Метод read().
Метод read() читает строку из открытого файла.

## Синтаксис метода read().

my_file.read([count])
Необязательный параметр count - это количество байт, которые следует прочитать из открытого файла. Этот метод читает информацию с начала файла и, если параметр count не указан, до конца файла.

Например, прочтем созданный нами файл some.txt:
```
my_file = open("some.txt")
my_string = my_file.read()
print("Было прочитано:")
print(my_string)
my_file.close()
```

f.readline() читает одну строку из файла; символ новой строки (\n) остаётся в конце прочитанной строки и отсутствует при чтении последней строки файла только если файл не оканчивается пустой строкой. Засчёт этого возвращаемое значение становится недвусмысленным: если f.readline() возвращает пустую строку — достигнут конец файла, в то же время незаполненная строка, представленная посредством '\n', содержит лишь символ новой строки.
````
f.readline()
f.readline()
```
f.readlines() возвращает список, содержащий все строки с данными, обнаруженные в файле. Если передан необязательный параметр подсказка_размера, функция читает из файла указанное количество байт, плюс некоторое количество байт сверх, достаточное для завершения строки, и формирует список строк из результата. Функция часто используется для построчного чтения больших файлов, эффективного засчёт отсутствия необходимости загрузки файла в память полностью. Возвращены будут только полные (завершённые) строки.
```
f.readlines()

mynewhandle = open("test.txt", "r")
while True:                            # Keep reading forever
    theline = mynewhandle.readline()   # Try to read next line
    if len(theline) == 0:              # If there are no more lines
        break                          #     leave the loop

    # Now process the line we've just read
    print(theline, end="")

mynewhandle.close()
```

Альтернативный способ построчного чтения - прохождение циклом по объекту файла. Он быстр, рационально использует память и имеет простой код в результате:
```
for line in f:
    print line,
``` 

Альтернативный способ проще, но не предоставляет тонкого контроля над происходящим. Поскольку оба этих способа работают с буферизацией строк по разному, не следует их смешивать.

## Запись в файл в Python. Метод write().

Метод write() записывает любую строку в открытый файл. Важно помнить, что строки в Python могут содержать двоичные данные, а не только текст.
Метод write() не добавляет символ переноса строки ('\n') в конец файла.

## Синтаксис метода write().
```
my_file.write(string);

my_file = open("some.txt", "w")
my_file.write("Мне нравится Python!\nЭто классный язык!")
my_file.close()
```
Вышеприведенный код создаст файл some.txt и запишет в него указанную строку.

## Добавление в файл. Метод write()

f.write(строка) записывает содержимое строки в файл и возвращает None.
```
f.write('Это тест\n')
```
Если вы хотите не перезаписать файл полностью (что делает метод write в случае открытия файла в режиме 'w'), а только добаить какой-либо текст, то файл следует открывать в режиме 'a' - appending. После чего использовать все тот же метод write.

### Удалит существующую информацию в some.txt и запишет "Hello".
```
my_file = open("some.txt", 'w')
my_file.write("Hello")
my_file.close()
```
### Оставит существующую информацию в some.txt и добавит "Hello".
```
my_file = open("some.txt", 'a')
my_file.write("Hello")
my_file.close()
```

Чтобы записать в файл нечто отличное от строки, предварительно это нечто нужно в строку сконвертировать:
```
value = ('ответ', 42)
s = str(value)
f.write(s)


f = open("friends.txt", "r")
xs = f.readlines()
f.close()

xs.sort()

g = open("sortedfriends.txt", "w")
for v in xs:
    g.write(v)
g.close()
```


## С помощью метода writelines() можно записать в файл итерируемую последовательность.
```
a = [1,2,3,4,5,6,7,8,9,0]
f = open("text2.txt",'w')
f.writelines("%s\n" % i for i in a)
f.close()

open("text2.txt").read()

print(open("text2.txt").read())
```

## Как узнать позицию указателя в файле в Python.

После того как вы вызвали метод read() на файловом объекте, если вы повторно вызовете read(), то увидите лишь пустую строку. Это происходит потому, что после первого прочтения указатель находится вконце файла. Для того чтобы узнать позицию указателя можно использовать метод tell().

```
my_file = open("some.txt")
my_file.read(10)
print ("Я на позиции:", my_file.tell())
my_file.close()
```

f.tell() возвращает целое, представляющее собой текущую позицию в файле объекта файла f, измеренную в байтах от начала файла. 

Чтобы изменить позицию объекта файла, используйте "f.seek(смещение, откуда)". Позиция вычисляется засчёт сложения смещения и точки отсчёта; точка отсчёта выбирается из аргумента откуда. 

### Синтаксис метода seek().
```
my_file.seek(offset, [from])
```
Аргумент offset указывет на сколько байт перейти.  

опциональный аргумент from означает позицию, с которой начинается движение. 
- 0 - отмеряет смещение от начала файла
- 1 - применяет текущую позицию в файле
- 2 - в качестве точки отсчёта использует конец файла

Аргумент откуда может быть опущен и по умолчанию устанавливается в 0, используя начало файла в качестве точки отсчёта.

Например:
```
my_file = open("some.txt", "r")
print(my_file.read(10))
print("Мы находимся на позиции: ", my_file.tell())
```
### Возвращаемся в начало
```
my_file.seek(0)
print(my_file.read(10))
my_file.close()

```
### Перейти к шестому байту в файле
```
f = open('/tmp/workfile', 'r+')
f.write('0123456789abcdef')
f.seek(5)     
f.read(1)        
```
### Перейти к третьему байту с конца 
```
f.seek(-3, 2) 
f.read(1)
```
Когда вы закончили все действия над файлом, вызовите f.close() чтобы закрыть его и освободить все системные ресурсы, использованные при открытии этого файла. Все попытки использовать объект файла после вызова f.close() будут завершены неудачей.
```
f.close()
f.read()
```
Считается хорошей манерой использовать ключевое слово with при работе с объектами файлов. Преимущество этого способа в том, что файл всегда корректно закрывается после выполнения блока, либо если при выполнении было порождено исключение. Кроме того, получающийся код намного короче, чем эквивалентная форма с блоками try-finally:
```
with open('/tmp/workfile', 'r') as f:
    read_data = f.read()
f.closed
```
У объектов файла есть ещё несколько дополнительных методов, таких как isatty() и truncate(), которые используются не так часто; 

## 1.py
Чтение файла строка за строкой
Чтение файла мало чем отличается от чтения книги. Например, чтобы прочитать книгу, мы должны по крайней мере, открыть ее. То же и с файлом — нам нужно создать file object, который мы обозначим переменной infile:
```
infile = open('data1.txt', 'r')
```
Первый аргумент понятен — мы называем имя файла, который мы должны открыть (open). Второй аргумент, строка 'r', говорит, что мы хотим открыть файл для чтения (reading). Далее мы увидим, что он может быть открыт и для записи, тогда вторым аргументом будет 'w' (writing). Как и прочитанную книгу, файл желательно закрыть, с помощью инструкции infile.close()
Но закрывать еще рано. Читать файл мы можем разными способами. Простейший из них — построчное чтение с помощью цикла for:
```
for line in infile:
    # do something with line
```
То есть синтаксис такой же, как при чтении списка, только вместо списка — файл, а вместо элементов — строки. Вместо того, чтобы читать поочередно каждую строку, можно загрузить их все в список строк с помощью функции readlines в список lines. Ниже представлено три способа, дающих один и то же список lines:
```
lines = infile.readlines()

lines = []
for line in infile:
    lines.append(line)

lines = [line for line in infile]
```
## 2.py
Итак, мы загрузили файл строка за строкой в список lines. Далее мы хотим посчитать среднее значение полученных нами измерений. При этом помним, что загрузили мы именно строки, то есть у нас список объектов string. А работать нам нужно с float-числами. Мы уже не раз с этим сталкивались и знаем что делать:
```
mean = 0
for line in lines:
    number = float(line)
    mean = mean + number
mean = mean/len(lines)
```
## 3.py
Суммирование чисел — часто встречающаяся операция, поэтому в Python есть и встроенная функция sum, умеющая складывать элементы списка. И здесь мы можем воспользоваться генерацией списка, решающей задачу существенно короче:
```
mean = sum([float(line) for line in lines])/len(lines)
```

### 4.py
Другой вариант — мы можем не создавать список строк, а сразу же записывать числа и получить полное решение нашей задачи в пять строчек:
```
infile = open('data1.txt', 'r')
numbers = [float(line) for line in infile.readlines()]
infile.close()
mean = sum(numbers)/len(numbers)
print mean
```

## 5.py Чтение файла целиком
У файлов имеется и другой метод чтения — read, читающий файл целиком, возвращая его в виде одной строки:
```
infile = open('data1.txt', 'r')
filestr = infile.read()
print filestr

words = filestr.split()

numbers = [float(w) for w in words]
mean = sum(numbers)/len(numbers)
print mean

```
Более компактное элегантное решение:
```
infile = open('data1.txt', 'r')
numbers = [float(w) for w in infile.read().split()]
mean = sum(numbers)/len(numbers)
```
## Чтение смешанного файла 6.py
Многие данные представляются не только в форме чисел, но и слов. Например, у нас есть файл, рассказывающий нам о средних атмосферных осадках, выпадающий каждый месяц в Риме, и записано это в виде файла rainfall.dat

по этому файлу построить график. Помня про метод split, мы можем построчно прочитать файл и разбить каждую строку на два элемента. Далее выбираем каждый второй элемент и составляем список чисел, соответствующий месяцам:
```
def extract_data(filename):
    infile = open(filename, 'r')    
    infile.readline()      # пропускаем первую строчку
    numbers = []
    for line in infile:
        words = line.split()
        number = float(words[1])
        numbers.append(number)
    infile.close()
    return numbers

values = extract_data('rainfall.dat')



import matplotlib.pyplot as plt
month_indices = range(1, 13)
plt.plot(month_indices, values[:-1], 'o--')
plt.show()

zip(month_indices, values) 
```
Заметьте, что первую строку мы пропускаем, поскольку для решения самой задачи она нам не нужна и цикл for записывает список, начиная со второй строки. Но, например, если у нас имеется много схожих файлов, оформленных в одинаковом стиле, можно использовать эту первую комментирующую строку как аргумент для названия графиков, передавая ее функциям plt.savefig() или plt.title().

Также мы видим, что в dat-файле в последней строке имеется значение суммарных средних осадков, что нам не нужно, так как мы строим график для каждого месяца. Поэтому мы используем срез списка values[:-1], исключая таким образом последний элемент.
Цикл for при желании можно заменить генерацией списков 7.py:
```
def extract_data(filename):
    infile = open(filename, 'r')
    infile.readline()
    numbers = [float(line.split()[1]) for line in infile]
    infile.close()
    return numbers
```
## Запись в файл
Основная функция для этого действия по форме не отличается от чтения — outfile.write(s), где outfile — имя файла, а s — передаваемая строка. При этом для разделения строк не стоит забывать про символ переноса, если его там не имеется:
```
outfile.write(s + '\n')
```
Простая запись может осуществляться двумя способами, которые определяются по второму аргументу, когда мы открываем файл:

# записать в новый файл или перезаписать старый
```
outfile = open(filename, 'w')
```
# добавить в конец существующего файла
```
outfile = open(filename, 'a')
```

## Запись таблицы
Рассмотрим запись в файл на примере таблицы, оформленной в виде вложенного списка:
```
[[ 0.75,          0.29619813,  -0.29619813,  -0.75      ],
 [ 0.29619813,    0.11697778,  -0.11697778,  -0.29619813],
 [-0.29619813,   -0.11697778,   0.11697778,   0.29619813],
 [-0.75,         -0.29619813,   0.29619813,   0.75      ]]
```

В конце каждой строки мы должны вставить символ перехода на новую. И тогда код будет выглядеть так 8.py:

```
data = [[ 0.75,          0.29619813,  -0.29619813,  -0.75      ],
        [ 0.29619813,    0.11697778,  -0.11697778,  -0.29619813],
        [-0.29619813,   -0.11697778,   0.11697778,   0.29619813],
        [-0.75,         -0.29619813,   0.29619813,   0.75      ]]

outfile = open('tmp_table.dat', 'w')
for row in data:
    for column in row:
        outfile.write('%14.8f' % column)
    outfile.write('\n')
outfile.close()
```

немного форматирования к предыдущей программе 9.py:
```
data = [[ 0.75,        0.29619813, -0.29619813, -0.75      ],
        [ 0.29619813,  0.11697778, -0.11697778, -0.29619813],
        [-0.29619813, -0.11697778,  0.11697778,  0.29619813],
        [-0.75,       -0.29619813,  0.29619813,  0.75      ]]

outfile = open('tmp_table.dat', 'w')
ncolumns = len(data[0])
outfile.write('          ')
for i in range(1, ncolumns+1):
    outfile.write('%10s    ' % ('column %2d' % i))
outfile.write('\n')
row_counter = 1
for row in data:
    outfile.write('row %2d' % row_counter)
    for column in row:
        outfile.write('%14.8f' % column)
    outfile.write('\n')
    row_counter += 1

outfile.close()
```

Возможен и другой способ создания этого цикла — использовать индексацию вложенных списков 10.py:
```
for i in range(len(data)):
    outfile.write('row %2d' % (i+1))
    for j in range(len(data[i])):
        outfile.write('%14.8f' % data[i][j])
    outfile.write('\n')

outfile.close()

```

## Чтение и запись табличных файлов

Данные в виде таблиц также называют CSV (comma separated values) — буквально «значения, разделенные запятыми». Это текстовый формат, предназначенный для представления табличных данных. Каждая строка файла — это одна строка таблицы. Значения отдельных колонок разделяются разделительным символом — запятой (,) , точка с запятой (;) или другим символом. CSV могут быть легко прочитаны и обработаны Python.
Файл может быть записан в CSV формате:
```
,"year 1","year 2","year 3"
"person 1",651000,651000,651000
"person 2",1100500,950100,340000
"person 3",740000,780000,800000
```
## Чтение CSV-файлов
Мы можем прочитать CSV-файл строка за строкой, используя стандартный модуль csv 11.py.
```
infile = open('budget.csv', 'r')
import csv
table = []
for row in csv.reader(infile):
    table.append(row)
infile.close()
```

12.py вложенный список:
```
table = [row for row in csv.reader(infile)]
```
Таблицу легко распечатать с помощью модуля pretty print:
```
import pprint
pprint.pprint(table)
```
Заметим важную особенность csv модуля — он возвращает все в виде строк. Для трансформации того текста, что представлен числами мы предпринимаем следующий цикл:
```
for r in range(1,len(table)):
    for c in range(1, len(table[0])):
        table[r][c] =  float(table[r][c])
```

## Обработка данных

13.py - добавим строку, рассчитывающую сумму за каждый год, то есть суммирующую числа в столбцах:
```
row = [0.0]*len(table[0])
row[0] = 'sum'
for c in range(1, len(row)):
    s = 0
    for r in range(1, len(table)):
        s += table[r][c]
    row[c] = s

table.append(row)
```

## Запись в CSV-файл

```
outfile = open('budget.csv', 'w')
writer = csv.writer(outfile)
for row in table:
    writer.writerow(row)
outfile.close()
```
14.py:
```
infile = open('budget.csv', 'r')
import csv
table = []
for row in csv.reader(infile):
    table.append(row)
infile.close()

import pprint
pprint.pprint(table)

# трансформируем числа из string в float
# (оставляя в покое первую строку и первый столбец)
for r in range(1,len(table)):
    for c in range(1, len(table[0])):
        table[r][c] = float(table[r][c])
pprint.pprint(table)

# добавляем строку с суммой
row = [0.0]*len(table[0])
row[0] = 'sum'
for c in range(1, len(row)):
    s = 0
    for r in range(1, len(table)):
        s += table[r][c]
    row[c] = s
table.append(row)
pprint.pprint(table)

outfile = open('budget2.csv', 'w')
writer = csv.writer(outfile)
for row in table:
    writer.writerow(row)
outfile.close()

```

## Делаем словари 15.py
Представим, у нас есть информация о температуре в трех городах: Осло, Лондон и Париж. Для того чтобы ее сохранить, мы создаем список:
```
temps = [13, 15.4, 17.5]
```
Но для того, чтобы запомнить принадлежность к городам, нам нужно соотнести индексы списка и города:
```
temps = {'Oslo': 13, 'London': 15.4, 'Paris': 17.5}
# или
temps = dict(Oslo=13, London=15.4, Paris=17.5)
```
мы узнали температуру в Мадриде:
```
temps['Madrid'] = 26.0
print temps
```
## Операции со словарями
Строковые «индексы» в словарях называются ключами, keys. И для того, чтобы пройти циклом по словарю мы можем писать for key in d и сопоставлять ему значение, записываемое в форме d[key].

```
for city in temps:
    print 'The temperature in %s is %g' % (city, temps[city])
```

Мы можем проверить, есть ли в нашей базе данных в виде словаря данные о каком-то городе:
```
if 'Berlin' in temps:
    print 'Berlin:', temps['Berlin']
else:
    print 'No temperature data for Berlin'
```
Запись вида key in d представляет собой обычное булево выражение:
```
'Oslo' in temps
```
И ключи, и значения можно достать из словаря в виде списков:
```
temps.keys()

temps.values()

```
Важная особенность словарей в том, что порядок элементов в возвращаемом списке ключей непредсказуем. Если вам нужно задать определенный порядок ключей, нужно их отсортировать. Вот цикл, расставляющий их в алфавитном порядке:
```
for city in sorted(temps):
    print city
```
Пара ключ-значения может быть удалена с помощью del d[key]:
```
del temps['Oslo']

len(temps) 
```

Когда нам нужно скопировать словарь:
```
temps_copy = temps.copy()
del temps_copy['Paris']   # это не затронет temps

```

Если же две переменные ссылаются на один словарь, и мы меняем одну из них, то это скажется и на другой:
```
t1 = temps
t1['Stockholm'] = 10.0       # поменяли  t1
print temps    # temps также изменилось
```

### Полиномы 16.py
Вообще говоря, ключами в словарях могут выступать не только строки, а любые неизменяемые объекты. То есть это могут быть int, float, complex, str и tuple. И с помощью ключей в виде int объектов, это оказывается удобным, например, как будет показано далее для представления многочленов. 

Рассмотрим полином:
~p(x) = -1 + x^2 + 3x^7.

Данные о полиноме могут быть эффективно представлены в виде словаря, где ключами служат степени x, а значениями — коэффициенты при этих степенях. 
```
p = {0: -1, 2: 1, 7: 3}
```
Используя такую запись словарей, мы можем придумать функцию, которая возвращает значение для заданного в такой форме полинома и численного значения x:

```
def poly1(data, x):
    sum = 0.0
    for power in data:
        sum += data[power]*x**power
    return sum
```
# или более емкая запись с использованием sum:
```
def poly1(data, x):
    return sum([data[p]*x**p for p in data])
```
## Чтение из файла
файл densities.dat - таблица о плотностях разных веществ:
```
air            0.0012
gasoline       0.67
ice            0.9
pure  water    1.0
seawater       1.025
human  body    1.03
limestone      2.6
granite        2.7
iron           7.8
silver         10.5
mercury        13.6
gold           18.9
platinium      21.4
Earth  mean    5.52
Earth  core    13
Moon           3.3
Sun  mean      1.4
Sun  core      160
proton         2.8E+14
```
Ключами у нас будут названия веществ, а значениями их плотности. Для переноса информации из файла в словарь, мы построчно прочитаем файл densities.dat, разобьем строки на слова, и конвертируем каждое второе слово в число 17.py:
```
def read_densities(filename):
    infile = open(filename, 'r')
    densities = {}
    for line in infile:
        words = line.split()
        density = float(words[-1])

        if len(words[:-1]) == 2:  #для объектов, состоящих из более чем одного слова (Sun core)
            substance = words[0] + ' ' + words[1]
        else:
            substance = words[0]

        densities[substance] = density
    infile.close()
    return densities

densities = read_densities('densities.dat')

print(densities)
```
## Вложенные словари
у нас есть файл данных table.dat, представленный в виде таблицы:
```
            A          B          C         D
1         11.7       0.035       2017      99.1
2          9.2       0.037       2019     101.2
3         12.2         no         no      105.2
4         10.1       0.031        no      102.1
5          9.1       0.033       2009     103.3
6          8.7       0.036       2015     101.9
```

Можно воспринимать вложенные словари просто как то, что значением, соответствующим ключу может быть практически любой тип объектов, в том числе и словарь. 
```
infile = open('table.dat', 'r')
lines = infile.readlines()
infile.close()
data = {}
first_line = lines[0]
properties = first_line.split()
for p in properties:
    data[p] = {}

for line in lines[1:]:
    words = line.split()
    i = int(words[0])
    values = words[1:]
    for p, v in zip(properties, values):
        if v != 'no':
            data[p][i] = float(v)

for p in data:
    values = data[p].values()
    data[p]['mean'] = sum(values)/len(values)

for p in sorted(data):
    print 'Mean value of property %s = %g' % (p, data[p]['mean'])

```

В первых трех строчках мы открыли файл для чтения, прочитали и закрыли. Далее создали пустой словарь, в который мы будем заносить данные, выделили первую строку (с индексом 0), разбили ее на слова, которые и есть наши A, B, C, D и сформировали первый уровень словаря data.

Далее срезом исключая рассмотренную строку, циклом проходимся по остальным строкам таблицы. Разбиваем каждую строку на слова. Каждое слово с индексом 0 это заголовок строки, оставшиеся слова — числа и слова 'no'. Для того, чтобы записать только известные данные в числовом формате, используется zip-проход, который и создает второй уровень вложенного словаря.
Следующий цикл находит среднее значение, а последний сортирует и выводит данные.

## Сравнение стоимости акций
Мы хотим сравнить эволюцию стоимости акций трех гигантов компьютерной индустрии: Microsoft, Sun Microsystems и Google. Соответствующие данные вы можете найти на finance.yahoo.com введя в строке поиска вверху слева имя компании и после этого выбрав слева вкладку Historical Prices. На этой странице мы можем выбрать временной интервал, для которого мы хотим просмотреть историю. Эти данные теперь мы можем загрузить на свой компьютер в виде табличного csv-файла и обозвать в стиле stockprice_name_of_company.csv.

Теперь можете посмотреть как они выглядят в вашем табличном процессоре. 
```
Date,Open,High,Low,Close,Volume,Adj Close
2015-09-01,602.359985,650.900024,594.099976,629.25,2679400,629.25
2015-08-03,625.340027,674.900024,565.049988,618.25,2625200,618.25
2015-07-01,524.72998,678.640015,515.179993,625.609985,2896600,625.609985
2015-06-01,536.789978,543.73999,520.50,520.51001,1655700,520.51001
2015-05-01,538.429993,544.190002,521.085022,532.109985,1723100,532.109985
2015-04-01,548.602417,571.142578,521.01239,537.340027,2116700,537.340027
2015-03-02,560.532532,577.912598,544.222473,548.002441,1828900,548.002441
...
```
Итак, содержание файла весьма простое. Первая строка содержит названия столбцов, первый из которых обозначает дату, а остальные различные измерения стоимости акций, среди которых мы будем следить за изменением последнего Adjusted Closing Price — скорректированной цены закрытия.
Сравнивать числа неинтересно, мы построим графики. Задача разбивается на две: прочитать файл, считав из него данные и построить по ним зависимости. Начнем с первой проблемы, для этого напишем читающую функцию 19.py:
```
def read_file(filename):
    infile = open(filename, 'r')
    infile.readline()       # читаем заголовки столбцов
    dates = [];  prices = []
    for line in infile:
        columns = line.split(',')     # разделяем по запятой
        date = columns[0]
        date = date[:-3]    # пропускаем день месяца (три последних цифры)
        price = columns[-1] # нам нужен только последний столбец
        dates.append(date)
        prices.append(float(price))   # не забываем конвертировать
    infile.close()
    dates.reverse()         # возвращаем порядок: от более старых к новым
    prices.reverse()        # и соответственно цены
    return dates, prices
```
Для того, чтобы прочитать файл достаточно вызвать функцию:
```
dates_Google,prices_Google  = read_file('stockprice_google.csv')
```
Вместо того, чтобы работать с разными переменными, удобно ввести словари с именами компаний в качестве ключей. Например, в двух словарях:
```
dates = {};  prices = {}
d, p = read_file('stockprice_sun.csv')
dates['Sun'] = d;  prices['Sun'] = p
d, p = read_file('stockprice_microsoft.csv')
dates['MS'] = d;  prices['MS'] = p
d, p = read_file('stockprice_google.csv')
dates['Google'] = d;  prices['Google'] = p
```
Мы также можем собрать словари дат и цен в один словарь данных:
```
data = {'prices': prices, 'dates': dates}

```
Словарь data вложенный, поэтому и обращения к нему имеют соответствующую форму, например, цены на акции Microsoft мы получим с помощью data['prices']['MS'].

### 20.py
Следующее, что мы должны сделать — нормировать данные, чтобы их было легко сравнивать. Идея в том, что Sun и Microsoft начинают с единичной ценой, а Google стартует позже, с лучшей на тот месяц из цен Sun и Microsoft. 

Нормировка для Sun и Microsoft тогда осуществляется делением на начальную стоимость акций 20.py:
```
norm_price = prices['Sun'][0]
prices['Sun'] = [p/norm_price for p in prices['Sun']]
norm_price = prices['MS'][0]
prices['MS'] = [p/norm_price for p in prices['MS']]
```
Нормировка для Google, как мы решили, требует от нас узнать цены для Sun и Microsoft для января 2015 года. Поскольку данные о датах и ценах расположены в списках, имеющих один порядок следования, мы можем найти индекс для '2015-01' в списке дат и использовать его для поиска соответствующей. Тогда нормировка:
```

jan15_MS = prices['MS'][dates['MS'].index('2015-01')]
jan15_Sun = prices['Sun'][dates['Sun'].index('2015-01')]
norm_price = prices['Google'][0]/max(jan15_MS, jan15_Sun)
prices['Google'] = [p/norm_price for p in prices['Google']]
```

### 21.py
И теперь наша цель построить график, показывающий как изменялись цены акций гигантов во времени. Проблема в том, что это самое время у нас представлено в виде строк, как, например, '2015-01'. Решить ее несложно, просто создав нужное количество точек x:
```
x = {}
x['Sun'] = range(len(prices['Sun']))
x['MS']  = range(len(prices['MS']))
```
Для Google, координата, с которой стартует график, другая, и это нужно учесть. Определяем индекс нужного месяца и ведем отсчет уже с него:
```
jan15 = dates['Sun'].index('2015-01')
x['Google'] = range(jan15, jan15 + len(prices['Google']), 1)
```

## 22.py Последний шаг — построить три зависимости:

```
import matplotlib.pyplot as plt

plt.plot(x['MS'], prices['MS'], 'g-')
plt.plot(x['Sun'], prices['Sun'], 'y-')
plt.plot(x['Google'], prices['Google'], 'r-')

plt.legend(['Microsoft', 'Sun', 'Google'], loc=0)
plt.grid()
plt.show()
```

## 22.py 
```
def read_file(filename):
    infile = open(filename, 'r')
    infile.readline()       # читаем заголовки столбцов
    dates = [];  prices = []
    for line in infile:
        columns = line.split(',')     # разделяем по запятой
        date = columns[0]
        date = date[:-3]    # пропускаем день месяца (три последних цифры)
        price = columns[-1] # нам нужен только последний столбец
        dates.append(date)
        prices.append(float(price))   # не забываем конвертировать
    infile.close()
    dates.reverse()         # возвращаем порядок: от более старых к новым
    prices.reverse()        # и соответственно цены
    return dates, prices

dates = {};  prices = {}
d, p = read_file('stockprices_sun.csv')
dates['Sun'] = d;  prices['Sun'] = p
d, p = read_file('stockprices_microsoft.csv')
dates['MS'] = d;  prices['MS'] = p
d, p = read_file('stockprices_google.csv')
dates['Google'] = d;  prices['Google'] = p

data = {'prices': prices, 'dates': dates}

# нормировка цен:
norm_price = prices['Sun'][0]
prices['Sun'] = [p/norm_price for p in prices['Sun']]
norm_price = prices['MS'][0]
prices['MS'] = [p/norm_price for p in prices['MS']]

jan15_MS = prices['MS'][dates['MS'].index('2015-01')]
jan15_Sun = prices['Sun'][dates['Sun'].index('2015-01')]
norm_price = prices['Google'][0]/max(jan15_MS, jan15_Sun)
prices['Google'] = [p/norm_price for p in prices['Google']]

# обозначаем "x" точки для построения графиков
x = {}
x['Sun'] = range(len(prices['Sun']))
x['MS']  = range(len(prices['MS']))
# для Google мы должны начать с января 2015:
jan15 = dates['Sun'].index('2015-01')
x['Google'] = range(jan15, jan15 + len(prices['Google']), 1)


import matplotlib.pyplot as plt

plt.plot(x['MS'], prices['MS'], 'g-')
plt.plot(x['Sun'], prices['Sun'], 'y-')
plt.plot(x['Google'], prices['Google'], 'r-')

plt.legend(['Microsoft', 'Sun', 'Google'], loc=0)
plt.grid()
plt.show()

```

## Модуль pickle

Строки могут с лёгкостью быть записаны в файл, или прочитаны из файла. В случае чисел нужно применить несколько больше усилий, поскольку метод read() возвращает только строки, которые придётся передать функции вроде int(), которая принимает строку в виде '123' и возвращает её числовое значение: 123. Однако, если вы намереваетесь сохранить более сложные типы данных, такие как списки, словари или экземпляры классов, всё становится несколько запутаннее.

Вместо того, чтобы принуждать программиста постоянно писать и отлаживать код для замысловатых типов данных, Python предоставляет стандартный модуль под названием pickle. Это замечательный модуль, который может принять любой объект Python (даже некоторые формы кода на Python!)и конвертировать его в строковое представление: этот процесс называется консервацией (pickling). Восстановление объекта из его строкового представления называется расконсервацией (unpickling): строка, описывающая объект, может быть сохранена в файл, добавлена к некоторым данным, или отослана через соединение по сети на удаленный компьютер.

Если у вас есть некоторый объект x и объект файла f, открытый на запись, простейший способ законсервировать объект требует одной-единственной строки кода:
```
pickle.dump(x, f)
```
Чтобы снова расконсервировать объект, при условии, что f — объект файла, открытого для чтения:
```
x = pickle.load(f)
```

pickle — стандартный способ для создания объектов Python, которые могут быть переиспользованы другими программами или будущими версиями этой же программы; для них есть технический термин — устойчивый объект (persistent object). Поскольку pickle используется часто, многие авторы расширений для Python заботятся о том, чтобы новые типы данных, такие как матрицы, могли быть корректно законсервированы и расконсервированы.


## Чтение данных из файла и запись в файл

Чтобы создать файл с помощью языка программирования Python, надо его открыть в режиме записи ('w', 'wb') или дозаписи ('a', 'ab').
f2 = open("text2.txt", 'w')

Объект, полученный в результате вызова функции open(), не обязательно связывать с переменной. В таком случае файл будет создан, но недоступен для программы.

создание файла с помощью функции open() не дает возможности контролировать именно создание нового файла, а не открытие ранее существующего. Поэтому, если такой контроль все же требуется, следует сначала проверить с помощью другой функции, существует ли файл.


Попытка открыть на чтение несуществующий файл вызывает ошибку.

Перехватить возникшее исключение можно с помощью конструкции try-except.
```
try:
    f = open("text10.txt")
except IOError:
    print ("No file")
```

Файл, открытый на запись, нельзя прочитать. Для этого требуется его закрыть, а потом открыть на чтение.

## Двоичные данные

```
f = open("somefile.zip", "rb")
g = open("thecopy.zip", "wb")

while True:
    buf = f.read(1024)
    if len(buf) == 0:
         break
    g.write(buf)

f.close()
g.close()

```

